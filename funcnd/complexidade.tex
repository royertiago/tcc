\section{Complexidade Funcional}

De posse do formalismo de funções não"=determinísticas,
finalmente,
concluímos a definição $\PhiNT$ e $\PhiNS$ para funções.
$\FDTIME$, $\FDSPACE$, $\FNTIME$ e $\FNSPACE$
são definidos para funções de maneira análoga às definições para decisores.
Por simetria, também definiremos $\coFNTIME$ e $\coFNSPACE$;
aqui, ao invés de tomarmos o máximo dentre os ramos,
pegaremos o mínimo para ser o valor da função.
(São as funções ``co"=não"=determinísticas'')
Nos concentraremos nas classes de complexidade de tempo,
onde o uso de não"=determinismo aparenta ter mais impacto.

\begin{definition}
    \begin{align*}
        \FP &= \bigcup_{k > 0} \FDTIME(n^k) \\
        \FNP &= \bigcup_{k > 0} \FNTIME(n^k) \\
        \coFNP &= \bigcup_{k > 0} \coFNTIME(n^k)
    \end{align*}
    \simbolo{$\FP$}{
        ``Funções determinísticas'' calculáveis em tempo polinomial
    }
    \simbolo{$\FNP$}{
        ``Funções não"=determinísticas'' calculáveis em tempo polinomial
    }
    \simbolo{$\coFNP$}{
        ``Funções co"=não"=determinísticas'' calculáveis em tempo polinomial
    }
\end{definition}

$\FP$ são as funções que podem ser calculadas
em tempo polinomial por máquinas determinísticas,
e $\FNP$, por máquinas não"=determinísticas\footnotemark.
$\coFNP$ é o análogo a $\coNP$.
\footnotetext{
    Nossa definição de $\FNP$ diverge da definição da literatura.
    A definição de \citeonline[p.~229]{Papadimitriou1994},
    por exemplo,
    é baseada em linguagens polinomialmente equilibradas
    (mencionadas na nota de rodapé~\ref{polinomialmente_equilibrada},
    na página~\pageref{polinomialmente_equilibrada}).

    Tome um problema de decisão $L \in \NP$
    e construa uma linguagem polinomialmente equilibrada $R_L$ associada a $L$.
    $R_L$ será um conjunto de pares $(x, y)$,
    em que $x \in L$ e $y$ é um ``certificado'' de que $x \in L$.

    O \emph{problema funcional associado} a $L$, $\class{F}L$,
    consiste em encontrar algum $y$ tal que $(x, y) \in R_L$,
    ou determinar que tal $y$ não existe;
    então,
    \citeonline[p.~229]{Papadimitriou1994} define $\FNP$
    como o conjunto de todos os $\class{F}L$
    para $L \in \NP$.

    Estes problemas são por vezes chamados de \emph{problemas de busca}
    (do inglês \emph{search problem}),
    em oposição a \emph{problemas de decisão}.

    A diferença crucial é que \citeauthoronline{Papadimitriou1994}
    pede apenas que encontremos algum $y$,
    enquanto que nossa definição exige que encontremos o maior deles.
}

\begin{example}
    Todos os algoritmos polinomiais
    discutidos em cursos de projeto e análise de algoritmos
    correspondem a funções em $\FP$.
    Por exemplo,
    temos cálculo de determinantes,
    programação linear\footnote{
        Programação linear é resolvível em tempo polinomial
        quando o domínio do problema são os números racionais.
        Se restringirmos o domínio da solução a números inteiros,
        o problema é $\NP$"=completo.

        Programação linear nos inteiros geralmente é chamada de
        \emph{programação inteira}
        (do inglês \emph{integer programming}).
    }
    e parsing de linguagens livres de contexto.
\end{example}

\begin{uproposition}
    Todas as funções características de problemas em $\NP$ estão em $\FNP$,
    e todas as funções características de problemas em $\coNP$ estão em $\coFNP$,
\end{uproposition}

\begin{example}
    Os problemas em $\NP$ podem ser facilmente generalizados para funções em $\FNP$.
    Por exemplo,
    podemos pegar uma máquina não"=determinística para $\SAT$,
    e modificá"=la para que,
    após achar uma atribuição de valores"=verdade,
    a escreva na fita.
    Caso contrário,
    escreva a palavra vazia.
    A função não"=determinística computada por esta máquina
    é a maior atribuição de valores"=verdade,
    lexicograficamente.
    Esta função está em $\FNP$.

    Similarmente,
    podemos encontrar o maior clique num grafo,
    achar fatores de um número,
    e encontrar um isomorfismo entre dois grafos
    usando o poder computacional de $\FNP$.

    Já problemas de minimização
    são mais facilmente interpretados como funções de $\coFNP$.
    Por exemplo,
    encontrar o caminho hamiltoniano de menor custo,
    e calcular o número cromático.
\end{example}
