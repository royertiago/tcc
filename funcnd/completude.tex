\section{Completude de problemas}

\subsection{Funções $\FNP$"=completas}

Da mesma forma como definimos problemas $\NP$"=completos,
queremos, de alguma forma,
representar completude dentro da classe $\FNP$.
No caso de $\NP$"=completude,
a redução de $L$ para $L'$ (por exemplo)
é feita por uma função $f$ de forma que
as ``respostas'' às questões ``$x \in L$?'' e ``$f(x) \in L'$?'' são as mesmas.
Há uma barreira trivial ao definir ``$\FNP$"=completude'' de maneira análoga,
que é a possibilidade de os contradomínios diferirem:
para toda função $f: \Sigma^* \to \Sigma^*$ em $\FNP$,
podemos construir uma função $g$ tal que $g(x) = \alpha$ para todo $x$,
para algum $\alpha \notin \Sigma$.
Isto é, para qualquer $x$, $g$ retorna a palavra com o único símbolo $\alpha$.
Como $\alpha \notin \Sigma$,
$f$ é inerentemente incapaz de produzir $\alpha$ na saída;
portanto, qualquer que seja a função de redução $h$,
$g(x)$ e $f(h(x))$ serão sempre diferentes.

Entretanto, intuitivamente,
lidar com $\Sigma$ diretamente não é estritamente necessário,
pois sempre podemos codificar os caracteres de $\Sigma$ usando binário.
Portanto,
para possibilitar uma definição direta de completude de funções,
assumiremos que o domínio e o contradomínio das funções de $\FNP$
é $\{0, 1\}^*$.

\begin{definition}
    Uma função $f$ é \emph{$\FNP$"=completa}
    se $f \in \FNP$ e,
    para toda função $g \in \FNP$,
    existir alguma função $h \in \FP$ tal que
    \begin{equation*}
        g(x) = f(h(x))
    \end{equation*}
    para todo $x \in \{0, 1\}^*$.
\end{definition}

Na definição de $\NP$"=completude,
a função $h$ que faz a redução é obrigada a ter a seguinte propriedade:
$x \in L$ se e somente se $f(x) \in L'$.
Ou seja, os valores booleanos das proposições
``$x \in L$'' e ``$h(x) \in L'$'' são os mesmos.
Se $g$ e $f$ são, respectivamente,
as funções características de $L$ e $L'$,
podemos expressar esta restrição como
$g(x) = f(h(x))$,
que é exatamente a expressão usada na definição de $\FNP$"=completude.
Portanto, de certa forma,
nossa definição de $\FNP$"=completude
é uma generalização da noção de $\NP$"=completude.

Podemos fabricar um problema $\FNP$"=completo usando o problema da parada,
mas impondo uma limitação no tempo de execução.

Dada uma máquina não"=determinística $M$,
uma entrada $x$
e uma limitação de tempo $n$,
defina o conjunto $T(M, x, n)$
como sendo o conjunto de todas as palavras deixadas na fita
após exatamente $n$ passos de computações não"=determinísticas de $M$ em $x$.
(Inclua também os resultados de ramos que pararam antes de $n$ passos.)
Caso todos os ramos de computação de $M$ encerrem em menos de $n$ etapas,
então $T(M, x, n)$ conterá todas as palavras das folhas da árvore de computação;
neste caso, a maior palavra (lexicograficamente) de $T(M, x, n)$
é $M(x)$.
Se existirem ramos de computação que não se encerram em $n$ etapas,
$T(M, x, n)$ conterá computações parciais,
que podem ser lexicograficamente maiores que $M(x)$;
portanto, neste caso, nada podemos afirmar sobre o máximo de $T(M, x, n)$.

Usaremos esta função $T$ para definir nossa função $\FNP$"=completa.

\begin{theorem}
    Defina a função $f: \{0,1\}^* \to \{0, 1\}^*$ por
    \begin{equation*}
        f(\langle M, x, n \rangle) = \max(T(M, x, n)),
    \end{equation*}
    em que $T$ é o conjunto definido acima
    e $\max$ é o máximo lexicográfico dentre as palavras do conjunto.
    Então $f$ é $\FNP$"=completa.
\end{theorem}

\begin{proof}
    Seja $g$ uma função de $\FNP$.
    Pela definição de $\FNP$, existe alguma máquina $M$
    e um polinômio $p$ tal que,
    ao rodar $M$ em $x$,
    todos os ramos de computação são mais curtos que $p(|x|)$,
    e $M(x) = g(x)$.

    Defina a função $h: \{0, 1\}^* \to \{0, 1\}^*$
    por
    \begin{equation*}
        h(x) = \langle M, x, 1^{p(|x|)} \rangle.
    \end{equation*}
    Como $M$ roda em tempo menor que $p(|x|)$,
    o maior valor (lexicograficamente) de $T(M, x, p(|x|))$ é $M(x)$,
    que é igual a $g(x)$ pois $M$ computa $g$.
    Portanto,
    \begin{equation*}
        f(h(x)) = M(x) = g(x).
    \end{equation*}

    O polinômio $p$ pode ser computado em tempo $O(p)$,
    e os outros dois termos da tripla $\langle M, x, 1^{p(|x|)} \rangle$
    só precisam ser copiados. Portanto, $h \in \FP$.

    Isso mostra que toda função de $\FNP$ é redutível a $f$;
    agora, falta mostrar que $f \in \FNP$.

    Para isso, simplesmente rode $M$ em $x$,
    usando o próprio não"=determinismo para simular o não"=determinismo de $M$
    e um contador para que o tempo de simulação não extrapole $n$.
    Então, apague todo o conteúdo da fita,
    deixando apenas o resultado da simulação de $M$ em $x$;
    depois encerre a computação.

    Desta forma, todas as folhas desta árvore de computação
    corresponderão exatamente aos valores de $T(M, x, n)$;
    portanto, o valor da função calculado por esta máquina não"=determinística
    é $f(\langle M, x, n \rangle)$,
    o que prova que $f \in \FNP$.
\end{proof}

\subsection{Oráculos Funcionais}

\begin{definition}[Oráculo funcional]
    Seja $f : \Sigma^* \rightarrow \Sigma^*$.
    Uma máquina que usa $f$ como oráculo
    possui uma fita especial para se ``comunicar'' com $f$.
    A máquina escreve uma palavra nesta fita,
    digamos $x$,
    e consulta o oráculo
    (isto é, transita para $q_?$).
    Caso $f(x)$ exista,
    a máquina transitará para $q_y$
    e o conteúdo da ``fita de comunicação'' é alterado para $f(x)$.
    Caso $f(x)$ não exista,
    a máquina transita para $q_n$,
    com a fita inalterada.
\end{definition}

Os estados $q_y$ e $q_n$ são apenas um preciosismo
para que a definição permita qualquer função como oráculo,
mesmo que não seja computável.
No caso de máquinas de Turing,
as funções computadas só não estarão definidas
nas entradas em que a máquina não parar.
Como estamos lidando com máquinas que possuem limites de tempo,
a máquina sempre para
(portanto a função sempre está definida),
tornando o estado $q_n$ redundante.

\begin{definition}
    Seja $\mathcal A$ um conjunto de funções.
    $\FP^\mathcal A$ é o conjunto das funções
    que podem ser calculadas em tempo polinomial
    por alguma máquinas de Turing que usa alguma função de $\mathcal A$ como oráculo.
    Caso $\mathcal A$ seja um conjunto de linguagens,
    interpretaremos a máquina como usando a função característica correspondente.
    $\FNP^\mathcal A$ e $\coFNP^\mathcal A$
    são definidas de maneira análoga.
    \simbolo{$\FP^\mathcal A$}{$\FP$ usando um oráculo de $\mathcal A$}
    \simbolo{$\FNP^\mathcal A$}{$\FNP$ usando um oráculo de $\mathcal A$}
    \simbolo{$\coFNP^\mathcal A$}{$\coFNP$ usando um oráculo de $\mathcal A$}
\end{definition}

$\FP^\mathcal A$, $\FNP^\mathcal A$ e $\coFNP^\mathcal A$
são os análogos funcionais de
$\P^\mathcal A$, $\NP^\mathcal A$ e $\coNP^\mathcal A$,
respectivamente.
