\documentclass[utf8,notheorems]{beamer}
\usetheme[compress]{Singapore}

\usepackage[brazil]{babel}
\usepackage{tikz}
\usetikzlibrary{calc}
\usetikzlibrary{decorations.pathmorphing}

\newtheorem*{theorem}{Teorema}
\newtheorem*{corollary}{Corolário}
\theoremstyle{definition}
\newtheorem*{definition}{Definição}

\let\C\someundefinedcommand
\let\G\someundefinedcommand
% These two commands are defined by hyperref in file puenc.def,
% and conflict with complexity - which also defines them.
% \C encodes some unicode character (U+030f), \G is textdoublegrave.
% Seems safe to simply undefine them.
\usepackage{complexity}

% Desenha uma máquina de Turing usando o TikZ.
% Parâmetros:
% #1 - Canto inferior esquerdo do desenho
% #2 - Fita a ser usada
%   A fita deve estar num formato apropriado para ser iterada
%   usando \foreach \x in {#2}
% #3 - Posição da cabeça da fita, indexado em zero
% #4 - Conteúdo da cabeça da fita
%
% As células da máquina terão tamanho 0.5;
% a cabeça da máquina será um quadrado de lado 0.75.
\newcommand\drawTuringMachine[4]{
    % Desenha a fita
    \foreach \letter[count=\index] in {#2} {
        \draw #1 ++(\index/2 - 0.5, 0) rectangle ++(0.5, 0.5);
        \path #1 ++(\index/2 - 0.25, 0.25) node {\strut\letter};
    }

    % Desenha a célula rasgada à direita
    \draw #1 ++(\index/2, 0) -- +(0.25, 0) +(0, 0.5) -- +(0.25, 0.5);
    \draw[decorate, decoration={zigzag, segment length = 4pt, amplitude = 1pt}]
        #1 ++(\index/2 + 0.25, 0) -- +(0, 0.5);

    % Desenha a cabeça da fita
    \draw #1 ++(#3/2 + 0.25, 0.5) % Centro da aresta de cima da célula selecionada
        -- ++(120:0.25) -- ++(0:0.25) -- ++(-120:0.25) % Triângulo equilátero
        ++(120:0.25) ++(-0.25, 0) rectangle +(0.75, 0.75) % Quadrado acima do triângulo
        ++(0.375, 0.375) node {#4}; % Estado no centro do quadrado
}

\begin{document}

\author{Tiago Royer}
\title{
    Máquinas de Turing não-determinísticas \\
    como computadores de funções
}
\date{12 de novembro de 2015}
\institute{UFSC}
\begin{frame}
    \titlepage
\end{frame}

\section{Máquinas e Funções}
\subsection{Decisão vs Busca}

\begin{frame}
    \frametitle{Problemas de decisão vs problemas de busca}
    \centering
    \begin{tikzpicture}
        \drawTuringMachine{(0, 5)}{a,a,b,b,\textvisiblespace}{0}{$q_0$}
        \node at (1.25, 4.625) {$\downarrow$};
        \drawTuringMachine{(0, 2.75)}{x,a,b,b,\textvisiblespace}{1}{$q_3$}
        \node at (1.25, 2.25) {$\vdots$};
        \drawTuringMachine{(0, 0)}{x,x,y,y,\textvisiblespace}{3}{$q_a$}
        \node at (3.5, 1) {Aceita/rejeita};

        \begin{scope}[xshift = 6cm]
            \drawTuringMachine{(0, 5)}{a,a,b,b,\textvisiblespace}{0}{$q_0$}
            \node at (1.25, 4.625) {$\downarrow$};
            \drawTuringMachine{(0, 2.75)}{a,a,b,b,\textvisiblespace}{1}{$q_0$}
            \node at (1.25, 2.25) {$\vdots$};
            \drawTuringMachine{(0, 0)}{
                $1$,$0$,\textvisiblespace,\textvisiblespace,\textvisiblespace
            }{3}{$q_f$}
            \node at (3.5, 1) {Retorna ``$10$''};
        \end{scope}
    \end{tikzpicture}
\end{frame}

\begin{frame}
    \frametitle{Problemas de decisão com máquinas não-determinísticas}
    \centering
    \begin{tikzpicture}[font=\tiny, scale=0.666]
        \drawTuringMachine{(0.333, 0)}{$p$,$\land$,$q$}{0}{$q_0$};

        \draw[->] (0.5, -0.25) -- ++(-0.5, -0.5);
        \drawTuringMachine{(-1.5, -2.5)}{$\mathbf f$,$\land$,$q$}{1}{$q_1$};
        \draw[->] (2, -0.25) -- ++(0.5, -0.5);
        \drawTuringMachine{(2.5, -2.5)}{$\mathbf t$,$\land$,$q$}{1}{$q_2$};

        \draw[->] (-0.625, -2.75) -- ++(0, -0.5);
        \drawTuringMachine{(-1.5, -5)}{$\mathbf f$,$\land$,$q$}{1}{$q_r$};
        \node at(-2, -4) {Rejeita};

        \draw[->] (2.875, -2.75) -- ++(-0.333, -0.5);
        \drawTuringMachine{(1, -5)}{$\mathbf t$,$\land$,$\mathbf f$}{2}{$q_1$};
        \draw[->] (4, -2.75) -- ++(0.333, -0.5);
        \drawTuringMachine{(3.5, -5)}{$\mathbf t$,$\land$,$\mathbf t$}{2}{$q_2$};

        \draw[->] (2, -5.25) -- ++(0, -0.5);
        \drawTuringMachine{(1, -7.5)}{$\mathbf t$,$\land$,$\mathbf f$}{2}{$q_r$};
        \draw[->] (4.5, -5.25) -- ++(0, -0.5);
        \drawTuringMachine{(3.5, -7.5)}{$\mathbf t$,$\land$,$\mathbf t$}{2}{$q_a$};
        \node at(0.5, -6.5) {Rejeita};
        \node at(6, -6.5) {Aceita};
    \end{tikzpicture}
\end{frame}

\section{Motivação}

\subsection{Axiomas de Blum}
\begin{frame}
    \frametitle{Axiomas de Blum}
    \begin{itemize}
        \item $\DSPACE$, $\DTIME$, $\NSPACE$, $\NTIME$
        \item Axiomas de Blum permitem trabalhar com medidas de complexidade
            de maneira unificada
            \begin{itemize}
                \item Mas lida com funções em vez de problemas de decisão
            \end{itemize}
    \end{itemize}
\end{frame}

\subsection{Definição de Hopcroft e Ullman}
\begin{frame}
    \frametitle{Definição de Hopcroft e Ullman}
    ``We may establish that nondeterministic time and space
    satisfy the axioms if we make an intelligent definition of what it means
    for an NTM to compute a function.
    For example, we might say that $\phi_i(n) = j$
    if and only if there is some sequence of choices by $M_i$ with input $0^n$
    that halts with $0^j$ ond the tape,
    and no sequence of choices that leads to halting with some $0^k$, $k \neq j$,
    on the tape.''

    {\scriptsize
        Hopcroft e Ullman, \emph{Introduction to Automata Theory} (1979), pg.~313
    }

    \pause
    \begin{itemize}
        \item Se a máquina parar sempre, é determinístico
        \item Se a máquina às vezes não parar, é não-computável
    \end{itemize}
\end{frame}

\section{Funções não-determinísticas}

\subsection{Definição}
\begin{frame}
    \frametitle{Relação com funções booleanas}
    \begin{itemize}
        \item Instância $\SAT$ tautológica retorna $\{1\}$
        \item Instância $\SAT$ contraditória retorna $\{0\}$
        \item Instância $\SAT$ satisfazível, mas não tautológica retorna $\{0, 1\}$
    \end{itemize}
\end{frame}
\begin{frame}
    \frametitle{Definição}
    Seja $M$ uma máquina de Turing não-determinística
    e $x$ uma entrada.

    Se todos os ramos da computação de $M$ em $x$ pararem,
    chame de $M(x)$ o maior valor
    (lexicograficamente)
    dentre todos os ramos de computação.

    Se algum ramo não parar,
    deixe $M(x)$ indefinido.
\end{frame}

\section{Tradução de conceitos}

\subsection{$\NP$-completude funcional}
\begin{frame}
    \frametitle{$\NP$-completude funcional}
    \begin{definition}
        Uma função $f \in \FNP$ é $\FNP$-completa se,
        para toda função $g \in \FNP$
        existir alguma função $h \in \FP$ tal que
        \begin{equation*}
            g(x) = f(h(x)).
        \end{equation*}
    \end{definition}

    Problema completo: $\lang{CallbackSAT}$
\end{frame}

\subsection{Hierarquia polinomial}
\begin{frame}
    \frametitle{Hierarquia polinomial}
    \centering
    \begin{tikzpicture}
        \draw let \n1 = {0}, \n2 = {8}, \n3 = {1.5}, \n4 = {0.5} in
            (\n1, -\n4) -- (\n2, -\n4)
            (\n1, 0) -- (\n2, \n3)
            (\n1, \n3) -- (\n2, 0)
            (\n1, \n3) -- (\n2, 2*\n3)
            (\n1, 2*\n3) -- (\n2, \n3)
            (\n1, 2*\n3) -- (\n2, 3*\n3)
            (\n1, 3*\n3) -- (\n2, 2*\n3)
            (\n1, 4*\n3) -- (\n2, 4*\n3)
            (\n1, -\n4) -- (\n1, 4*\n3)
            (\n2, -\n4) -- (\n2, 4*\n3)
            node (a) at ({(\n1+\n2)/2}, 0) {
                $\Sigma_0^p = \Delta_0^p = \Pi_0^p = p$
            }
            node (a) at (\n1+2*\n4, \n3/2) {$\Sigma_1^p = \NP$}
            node (a) at (\n2-2*\n4, \n3/2) {$\Pi_1^p = \coNP$}
            node (a) at ({\n1+\n2/2}, \n3) {$\Delta_2^p = \P^\NP$}
            node (a) at (\n1+\n4, 3*\n3/2) {$\Sigma_2^p$}
            node (a) at (\n2-\n4, 3*\n3/2) {$\Pi_2^p$}
            node (a) at ({\n1+\n2/2}, 2*\n3) {$\Delta_3^p$}
            node (a) at (\n1+\n4, 5*\n3/2) {$\Sigma_3^p$}
            node (a) at (\n2-\n4, 5*\n3/2) {$\Pi_3^p$}
            node (a) at ({\n1+\n2/2}, 3*\n3) {$\vdots$}
            node (a) at ({\n1+\n2/2}, 7*\n3/2) {$\PH \subseteq \PSPACE$};
    \end{tikzpicture}
\end{frame}

\newlang\coFNP{coFNP}
\begin{frame}
    \frametitle{Hierarquia polinomial funcional}
    \begin{columns}
        \begin{column}{0.2\textwidth}
            \begin{align*}
                \Sigma_0^p &= \Delta_0^p = \Pi_0^p = \P \\
                \Sigma_{n+1}^p &= \NP^{\Sigma_n^p} \\
                \Delta_{n+1}^p &= \P^{\Sigma_n^p} \\
                \Pi_{n+1}^p &= \coNP^{\Sigma_n^p}
            \end{align*}
        \end{column}
        \begin{column}{0.2\textwidth}
            \begin{align*}
                \Sigma_0^f &= \Delta_0^f = \Pi_0^f = \FP \\
                \Sigma_{n+1}^f &= \FNP^{\Sigma_n^f} \\
                \Delta_{n+1}^f &= \FP^{\Sigma_n^f} \\
                \Pi_{n+1}^f &= \coFNP^{\Sigma_n^f}
            \end{align*}
        \end{column}
    \end{columns}
\end{frame}

\subsection{Fecho compositivo}
\begin{frame}
    \frametitle{Fecho compositivo}

    Se $\mathcal F$ é um conjunto de funções,
    chame de $\mathcal F^\circ$
    o \emph{fecho compositivo} de $\mathcal F$;
    isto é, o conjunto de todas as funções na forma
    \begin{equation*}
        f_1 \circ f_2 \circ \dots \circ f_n
    \end{equation*}
    para $f_1, \dots, f_n \in \mathcal F$.

    \begin{theorem}
        \begin{equation*}
            (\Sigma_n^f)^\circ = \Delta_{n+1}^f
        \end{equation*}
    \end{theorem}
\end{frame}

\section{Trabalhos futuros}
\begin{frame}
    \frametitle{Trabalhos futuros}
    \begin{itemize}
        \item Problemas completos
        \item Talvez a definição tenha ficado forte demais
        \item Relação com a classe $\OptP$, de Krentel
    \end{itemize}
\end{frame}

\end{document}
