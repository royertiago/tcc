\chapter{Complexidade Computacional}

% Funções de complexidade, que satisfazem aos axiomas de Blum
\newcommand{\PhiDT}{{\mathcal{T}}} % Tempo determinístico
\newcommand{\PhiDS}{{\mathcal{S}}} % Espaço determinístico
\newcommand{\PhiNT}{{\mathcal{N\!T}}} % Tempo não-determinístico
\newcommand{\PhiNS}{{\mathcal{N\!S}}} % Espaço não-determinístico

\emph{Complexidade} é a quantidade de recursos
que uma máquina de Turing gasta
para computar determinada função
ou para decidir pertinência a uma linguagem
\cite[p. 285]{HopcroftUllman1979}.
Os recursos mais importantes para a teoria de complexidade computacional
são o espaço e o tempo,
tanto determinísticos como não-determinísticos.

Embora seja possível trabalhar com estas medidas diretamente,
muitos resultados para uma medida
possuem análogos em outra medida.
Para simplificar a exposição,
escolhemos iniciar,
na seção \ref{axiomas_blum},
uma discussão sobre teoria de complexidade axiomática,
e definir as medidas padrão na seção \ref{medidas_padrao}.

\section{Teoria de Complexidade Axiomática: Axiomas de Blum}
\label{axiomas_blum}

(Utilizaremos a definição provida por
\citeonline[p. 156]{Papadimitriou1994}.)

Dada uma máquina de Turing $M$
e uma palavra $x$,
denotaremos por $M(x)$ a ``saída''
de $M$ quando lhe é dado $x$ na entrada.

\begin{definition}
    Uma \emph{medida de complexidade}
    é uma função $\Phi$ que satisfaz aos seguintes axiomas:
    \footnotemark
    \begin{enumerate} [label=\textbf{Axioma \arabic*}, ref=\arabic*, align=left]
        \item
            \label{blum_def}
            $\Phi(M, x)$ está definido
            se, e somente se,
            $M(x)$ está definido.
        \item
            \label{blum_rec}
            Dados $M$, $x$ e $k$,
            é decidível se $\Phi(M, x) = k$.
    \end{enumerate}

    \footnotetext{
        A definição usual dos axiomas de Blum
        (encontrada, por exemplo,
        no texto de \citeonline[p. 313]{HopcroftUllman1979}
        e no próprio artigo original de \citeonline[p. 3]{Blum1967})
        aparece no contexto de computadores de funções de inteiros.
        Seja $M_1, M_2, \dots$ uma enumeração de máquinas de Turing.
        Consideraremos que a máquina $M_i$
        computa a função recursiva parcial $\phi_i$.
        Uma medida de complexidade é uma lista de funções
        $\{\hat \Phi_1, \hat \Phi_2, \dots\}$
        que satisfaz os seguintes axiomas:

        \begin{enumerate} [label=Axioma \arabic*', ref=\arabic*', align=left]
            \item
                \label{blum_def_orig}
                $\hat \Phi_i(n)$ está definido
                se, e somente se,
                $\phi_i(n)$ está definido.
            \item
                \label{blum_rec_orig}
                A função $R(i, n, m)$,
                definida como $1$ se $\hat \Phi_i(n) = m$,
                e $0$ em caso contrário,
                é recursiva.
        \end{enumerate}

        As duas definições são análogas.
        O valor $\hat \Phi_i(n)$ corresponde a $\Phi(M_i, 0^n)$.
        O axioma \ref{blum_def} corresponde ao axioma \ref{blum_def_orig},
        enquanto que a decidibilidade exigida pelo axioma \ref{blum_rec}
        é expressada pela função $R$ no axioma \ref{blum_rec_orig}.
    }
\end{definition}

O axioma \ref{blum_rec}
nos dá um semialgoritmo para calcular $\Phi(M, x)$.
Entretanto, pelo axioma \ref{blum_def},
não podemos ir muito além disso,
pois $M(x)$ não está definido para todo $M$ e $x$.
De fato, sequer podemos decidir se $\Phi(M, x)$ existe.

\begin{example}
    \simbolo{$\PhiDT$}{Complexidade de Tempo}
    A \emph{complexidade de tempo},
    que denotaremos por $\PhiDT$,
    é a função que diz quantos movimentos
    uma máquina de Turing faz até retornar uma resposta.
    Isto é,
    \begin{equation*}
        \PhiDT(M, x) = \begin{cases}
            k, & \text{
                \parbox{0.6\textwidth}{
                    se $M$ executa exatamente $k$ passos em $x$ antes de parar.
                }
            } \\
            \text{indefinido}, & \text{
                \parbox{0.6\textwidth}{
                    caso $M$ nunca pare de computar $x$.
                }
            }
        \end{cases}
    \end{equation*}
    Para determinar se $\PhiDT(M, x) = k$,
    execute a máquina $M$ por $k$ passos
    e veja se é a primeira vez que
    $M$ atinge um estado aceitador.
    E, como $\PhiDT(M, x)$ só está definido se $M$ para ao computar $x$,
    $\PhiDT$ satisfaz aos dois axiomas de Blum.
\end{example}

\begin{example}
    \simbolo{$\PhiDS$}{Complexidade de Espaço}
    Para a \emph{complexidade de espaço},
    que denotaremos por $\PhiDS$,
    iremos assumir que $M$ possui uma fita somente-leitura
    específica para a entrada.
    \begin{equation*}
        \PhiDS(M, x) = \begin{cases}
            k, & \text{
                \parbox{0.6\textwidth}{%
                    se $M$ lê, de alguma de suas fitas,
                    exatamente $k$ células
                    antes de parar.
                }
            } \\
            \text{indefinido}, & \text{
                \parbox{0.6\textwidth}{
                    se $M$ nunca parar ao computar $x$.
                }
            }
        \end{cases}
    \end{equation*}
    É fácil ver que o axioma \ref{blum_def} é satisfeito.
    Para o axioma \ref{blum_rec},
    o algoritmo é um pouco mais complicado.

    Comece executando $M$ em $x$.
    Caso $M$ extrapole $k$ células lidas
    em alguma de suas fitas,
    podemos retornar rejeitar.
    Caso contrário,
    existirá um número finito de configurações da máquina.
    Existem $|\Gamma|^k$ possíveis fitas com $k$ termos;
    $k+1$ possíveis posições da cabeça de leitura;
    $|Q|$ possíveis estados da máquina;
    e $l$ diferentes fitas.
    No total, existem, no máximo,
    \begin{equation*}
        (k+1) l |Q||\Gamma|^k
    \end{equation*}
    possíveis configurações.
    Portanto, se a máquina executar
    mais movimentos do que este número,
    significa que ela entrou em loop.
    Podemos retornar rejeitar.

    E, por último,
    caso $M$ pare,
    precisamos nos assegurar que,
    de fato,
    em alguma das fitas $k$ células foram lidas.
\end{example}

\begin{example}
    \simbolo{$\PhiNT$}{Complexidade de Tempo não-determinística}
    \simbolo{$\PhiNS$}{Complexidade de Espaço não-determinística}
    Podemos adaptar $\PhiDT$ e $\PhiDS$
    para máquinas de Turing não\hyp{}determinísticas.

    Para a complexidade de tempo não-determinística,
    que denotaremos por $\PhiNT$,
    definiremos $\PhiNT(M, x)$
    como sendo a maior quantidade de movimentos
    tomadas por $M$ ao computar $x$
    dentre todas as escolhas de transições possíveis.

    Analogamente,
    para a complexidade de espaço não-determinística,
    que denotaremos por $\PhiNS$,
    definiremos $\PhiNS(M, x)$
    como sendo a maior quantidade de células lidas
    em qualquer dos ramos da computação de $M$ em $x$.
    Aqui, precisamos tomar o mesmo cuidado que tomamos
    com $\PhiDS$ para demonstrar o axioma \ref{blum_rec}.
\end{example}

\subsection{Classes de Complexidade}

\subsection{Teorema da União}

\section{Medidas de Complexidade Computacional}
\label{medidas_padrao}

% DTIME, DSPACE, NTIME, NSPACE

\subsection{Principais Classes de Complexidade Computacional}
% P, NP, PSPACE, EXP, NEXP, NEXPSPACE

\section{Hierarquias de Complexidade}

\subsection{Lema da Tradução}

\subsection{Hierarquia Polinomial}

\subsubsection{Oráculos}
