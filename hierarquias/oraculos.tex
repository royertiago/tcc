\section{Oráculos}

\begin{definition}
    Seja $A$ uma linguagem qualquer.
    Uma \emph{máquina de Turing com oráculo $A$}
    é uma máquina de Turing $M^A$ que possui uma fita especial
    e três estados adicionais: $q_?$, $q_y$ e $q_n$.
    Transitar para $q_?$ significa consultar o oráculo;
    ao fazer esta transição,
    caso a palavra nesta fita pertença à linguagem $A$,
    no próximo estado da computação $M$ transitará para $q_y$
    (a resposta foi positiva);
    caso contrário, $M$ transitará para $q_n$.
    \footnote{
        Observe que a cabeça da fita não se mexe durante a consulta.
        Portanto, a máquina pode escrever seu estado atual na fita
        antes de transitar para $q_?$ e recuperá-lo depois.
    }

    A definição de aceitação não é alterada.
    Chamaremos de $L^A(M)$ o conjunto das palavras aceitas por $M^A$.
\end{definition}

Intuitivamente, o oráculo é um dispositivo computacional
acoplado à máquina de Turing $M$.
É como se a máquina delegasse parte da computação
a outra máquina de Turing;
uma ``chamada de função''.

Observe que a única influência que $A$ possui em $M^A$
são as transições após $M$ ir para o estado $q_?$.
Ou seja, $A$ não pertence a $M$;
de fato, podemos ``acoplar'' várias linguagens diferentes
numa mesma máquina de Turing $M$
e obter diferentes $L^A(M)$ com isso%
\footnote{
    É exatamente por causa disso que,
    na notação do conjunto das palavras aceitas por $M^A$,
    o $A$ superscrito está junto de $L$, não de $M$.
}.

Iremos utilizar oráculos para definir a hierarquia polinomial,
uma generalização das classes $\P$ e $\NP$,
na seção \ref{hierarquia_polinomial}.

\subsection{Hierarquia de problemas indecidíveis}

É importante ressaltar que esta visão do oráculo $A$
como outra máquina de Turing acoplada à máquina principal
é puramente intuitiva;
a linguagem $A$ não precisa ser sequer computável
para que ela possa ser usada como oráculo.
De fato, \citeonline[p.~210]{HopcroftUllman1979}
introduzem este conceito no contexto de decidibilidade.
Intuitivamente, se houvesse um algoritmo para o problema da parada,
poderíamos resolver o problema da vacuidade para máquinas de Turing,
por exemplo.
Mas não podemos partir da premissa de que
``existe uma máquina de Turing que resolve o problema da parada'',
pois esta hipótese contradiz o teorema da parada.
Oráculos podem ser entendidos como uma formalização deste ``e se?''.

Mais precisamente, defina
\begin{align*}
    L_u^1 &= \{ \langle M, x \rangle \mid M \text{ aceita } x \} \\
    S_1 &= \{ \langle M \rangle \mid L(M) = \emptyset \}
\end{align*}
$L_u^1$ é o problema da parada; $S_1$ é o problema da vacuidade.

A demonstração padrão de que $S_1$ é indecidível
é uma redução do problema da parada para o problema da vacuidade.
Em essência, ela diz que,
caso houvesse um algoritmo para a vacuidade,
poderíamos usar este algoritmo para resolver o problema da parada.
Como não há algoritmo para a parada,
não pode haver algoritmo para a vacuidade.

Em termos de oráculos,
isso significa que podemos decidir $L_u^1$
utilizando um oráculo para $S_1$.
O oposto também ocorre:

Suponha que dispomos de um oráculo para $L_u^1$.
Se a entrada for $\langle M \rangle$,
construa uma máquina que enumere os pares $(i, j)$,
e, para cada par enumerado,
execute $M$ na $i$-ésima palavra por $j$ movimentos.
Caso $M$ aceite, aceite a entrada, qualquer que seja.
Caso contrário, enumere o próximo par, e tente de novo.
De posse desta máquina, peça ao oráculo se ela aceita $\varepsilon$
(ou qualquer palavra).
Se sim, significa que, em algum par $(i, j)$,
a $M$ aceitou a entrada $i$; portanto, $L(M) \neq \emptyset$.
Caso contrário, significa que $M$ nunca aceitou palavra alguma;
portanto, $L(m) = \emptyset$.

\begin{definition}
    Dois oráculos $A$ e $B$ são ditos equivalentes
    se existem máquinas $M$ e $N$ tais que
    $L^A(M) = B$ e $L^B(N) = A$.
\end{definition}

Isto é, usando uma linguagem como oráculo, conseguimos decidir a outra,
e vice-versa.
O que nós mostramos no parágrafo anterior é que
$L_u^1$ e $S_1$ são equivalentes.

A intuição por trás da equivalência é que,
ao ``programar'' uma máquina de Turing com oráculo $S_1$ (por exemplo),
podemos fingir que também podemos usar $L_u^1$ como oráculo,
e fazer uma ``chamada'' a este oráculo;
como eles são equivalentes,
há um algoritmo que traduz de um para outro,
portanto, podemos usar este algoritmo de tradução
para simular uma chamada a $L_u^1$.
