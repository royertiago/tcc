\section{Oráculos}

\begin{definition}
    Seja $A$ uma linguagem qualquer.
    Uma \emph{máquina de Turing com oráculo $A$}
    é uma máquina de Turing $M^A$ que possui uma fita especial
    e três estados adicionais: $q_?$, $q_y$ e $q_n$.
    Transitar para $q_?$ significa consultar o oráculo;
    ao fazer esta transição,
    caso a palavra nesta fita pertença à linguagem $A$,
    no próximo estado da computação $M$ transitará para $q_y$
    (a resposta foi positiva);
    caso contrário, $M$ transitará para $q_n$.
    \footnote{
        Observe que a cabeça da fita não se mexe durante a consulta.
        Portanto, a máquina pode escrever seu estado atual na fita
        antes de transitar para $q_?$ e recuperá-lo depois.
    }

    A definição de aceitação não é alterada.
    Chamaremos de $L^A(M)$ o conjunto das palavras aceitas por $M^A$.
\end{definition}

Intuitivamente, o oráculo é um dispositivo computacional
acoplado à máquina de Turing $M$.
É como se a máquina delegasse parte da computação
a outra máquina de Turing;
uma ``chamada de função''.

Observe que a única influência que $A$ possui em $M^A$
são as transições após $M$ ir para o estado $q_?$.
Ou seja, $A$ não pertence a $M$;
de fato, podemos ``acoplar'' várias linguagens diferentes
numa mesma máquina de Turing $M$
e obter diferentes $L^A(M)$ com isso%
\footnote{
    É exatamente por causa disso que,
    na notação do conjunto das palavras aceitas por $M^A$,
    o $A$ superscrito está junto de $L$, não de $M$.
}.

Iremos utilizar oráculos para definir a hierarquia polinomial,
uma generalização das classes $\P$ e $\NP$,
na seção \ref{hierarquia_polinomial}.

\subsection{Hierarquia de problemas indecidíveis}

É importante ressaltar que esta visão do oráculo $A$
como outra máquina de Turing acoplada à máquina principal
é puramente intuitiva;
a linguagem $A$ não precisa ser sequer computável
para que ela possa ser usada como oráculo.
De fato, \citeonline[p.~210]{HopcroftUllman1979}
introduzem este conceito no contexto de decidibilidade.
Intuitivamente, se houvesse um algoritmo para o problema da parada,
poderíamos resolver o problema da vacuidade para máquinas de Turing,
por exemplo.
Mas não podemos partir da premissa de que
``existe uma máquina de Turing que resolve o problema da parada'',
pois esta hipótese contradiz o teorema da parada.
Oráculos podem ser entendidos como uma formalização deste ``e se?''.

Mais precisamente, defina
\begin{align*}
    L_u^1 &= \{ \langle M, x \rangle \mid M \text{ aceita } x \} \\
    S_1 &= \{ \langle M \rangle \mid L(M) = \emptyset \}
\end{align*}
$L_u^1$ é o problema da parada; $S_1$ é o problema da vacuidade%
\footnote{
    A notação $S_n$ é usada tabmém por \citeonline[p. 210]{HopcroftUllman1979}.
    A notação $L_u^n$ é derivada da notação para o problema da parada
    destes mesmos autores \cite[p. 183]{HopcroftUllman1979}.
}.

A demonstração padrão de que $S_1$ é indecidível
é uma redução do problema da parada para o problema da vacuidade.
Em essência, ela diz que,
caso houvesse um algoritmo para a vacuidade,
poderíamos usar este algoritmo para resolver o problema da parada.
Como não há algoritmo para a parada,
não pode haver algoritmo para a vacuidade.

Em termos de oráculos,
isso significa que podemos decidir $L_u^1$
utilizando um oráculo para $S_1$.
O oposto também ocorre:

Suponha que dispomos de um oráculo para $L_u^1$.
Se a entrada for $\langle M \rangle$,
construa uma máquina que enumere os pares $(i, j)$,
e, para cada par enumerado,
execute $M$ na $i$-ésima palavra por $j$ movimentos.
Caso $M$ aceite, aceite a entrada, qualquer que seja.
Caso contrário, enumere o próximo par, e tente de novo.
De posse desta máquina, peça ao oráculo se ela aceita $\varepsilon$
(ou qualquer palavra).
Se sim, significa que, em algum par $(i, j)$,
a $M$ aceitou a entrada $i$; portanto, $L(M) \neq \emptyset$.
Caso contrário, significa que $M$ nunca aceitou palavra alguma;
portanto, $L(m) = \emptyset$.

\begin{definition}
    Dois oráculos $A$ e $B$ são ditos equivalentes
    se existem máquinas $M$ e $N$ tais que
    $L^A(M) = B$ e $L^B(N) = A$.
\end{definition}

Isto é, usando uma linguagem como oráculo, conseguimos decidir a outra,
e vice-versa.
O que nós mostramos no parágrafo anterior é que
$L_u^1$ e $S_1$ são equivalentes.

A intuição por trás da equivalência é que,
ao ``programar'' uma máquina de Turing com oráculo $S_1$ (por exemplo),
podemos fingir que também podemos usar $L_u^1$ como oráculo,
e fazer uma ``chamada'' a este oráculo;
como eles são equivalentes,
há um algoritmo que traduz de um para outro,
portanto, podemos usar este algoritmo de tradução
para simular uma chamada a $L_u^1$.

Muitos outros problemas podem ser demonstrados equivalentes
(neste sentido)
ao problema da parada,
como o problema da correspondência de Post \cite[p. 214]{HopcroftUllman1979}.
Entretanto,
nem todos os problemas podem ser resolvidos com oráculos para a parada.
De fato, a mesma técnica que mostra que a parada é indecidível
pode ser usado para gerar um problema indecidível
para máquinas que usam o problema da parada como oráculo.

Defina
\begin{align*}
    L_u^{n+1} &= \{ \langle M^{L_u^n}, x \rangle \mid M^{L_u^n} \text{ aceita } x \}, \\
    S_{n+1} &= \{ \langle M^{S_n} \rangle \mid L^{S_n}(M) = \emptyset \}.
\end{align*}
$L_u^{n+1}$ é o problema da parada
para máquinas de Turing que usam $L_u^n$ como oráculo;
$S_{n+1}$ é o problema da vacuidade
para máquinas de Turing que usam $S_n$ como oráculo%
\footnote{
    Observe que,
    se definirmos $L_u^0 = S_0 = \emptyset$
    (ou algum conjunto recursivo qualquer),
    a fórmula é válida também para $n = 1$.
}.
Podemos demonstrar por indução que $S_n$ é equivalente a $L_u^n$;
e, imitando o teorema da parada,
podemos mostrar que $L_u^n$ é indecidível para máquinas que usam $L_u^n$ como oráculo.

Defina
\begin{equation*}
    \R_n = \{ L \mid L = L^{L_u^n}(M) \text{ para alguma máquina $M^{L_u^n}$ } \}.
\end{equation*}
Ou seja, $\R_n$ é o conjunto das linguagens
que são decidíveis usando $L_u^n$ como oráculo%
\footnote{
    Se usarmos a convenção de que $L_u^0 = \emptyset$,
    o conjunto $\R_0$ é exatamente o conjunto das linguagens recursivas
    (comumentemente denotado por \R).
}.
O parágrafo anterior mostra que $L_u^{n+1}, S_{n+1} \notin \R_n$.

Podemos demonstrar (por indução) que $\R_n \subset \R_{n+1}$.
Desta forma,
criamos uma hierarquia de problemas indecidíveis.
\footnote{
    Em outras palavras,
    existem problemas ``mais indecidíveis'' que outros;
    é uma situação análoga à existência de infinitos de tamanhos diferentes.
}

Estes conjuntos também podem ser denotados por $\R^{L_u^n}$;
as ``linguagens recursivas que usam $L_u^n$ como oráculo''.
São as linguagens que são decididas
pelo mesmo tipo de máquina usado para definir $\R$,
mas equipados com um oráculo para $L_u^n$.

Observe que,
de posse de um oráculo para $S_n$ (por exemplo),
ao ``programar'' uma máquina de Turing com esse oráculo,
podemos ``fingir'' que podemos usar qualquer linguagem de $\R_n$ como oráculo
--- pois, pela definição de $\R_n$,
esta linguagem possui um algoritmo para resolvê-la
usando $S_n$ como oráculo.
De certa forma,
a linguagem $S_n$ é uma das ``mais difíceis'' de serem resolvidas,
dentre todas as linguagens de $\R_n$.

Intuitivamente, é como se pudéssemos usar qualquer linguagem de $\R_n$ como oráculo.
Abusando um pouco da notação,
podemos escrever
\begin{align*}
    \R_0 &= \R \\
    \R_{n+1} &= \R^{\R_n}.
\end{align*}
A interpretação é que $\R_{n+1}$ é o conjunto das linguagens
decididas pelas mesmas máquinas de $\R$,
mas agora equipadas com um oráculo para um problema ``mais difícil'' de $\R_n$.
Usaremos esta notação novamente na seção \ref{hierarquia_polinomial},
em que ``mais difícil'' significará,
por exemplo, ``\NP-completo''.
