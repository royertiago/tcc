\subsection{Funções Construtíveis}

Em alguns teoremas
(como, por exemplo, \ref{desperdicio_recursos} e \ref{funcao_fora_classe})
em que tivemos de calcular alguma função recursiva
para poder definir o conjunto em questão.
Naqueles casos,
os teoremas demonstrados tratavam de funções
que gastavam \emph{mais} recursos do que aquela função recursiva.
Por causa deste ``mais'',
não há problema
se o próprio algoritmo para calcular aquelas funções recursivas
for excessivamente custoso.

Entretanto,
em algumas demonstrações
(em especial as baseadas em diagonalizações),
precisaremos construir algumas máquinas de Turing
que rodarão satisfazendo alguma restrição de tempo ou espaço;
e estas máquinas precisarão computar algumas funções
para manter o controle sobre a computação.

Portanto,
estas funções precisarão ser,
de algum modo,
restritas a serem computadas sob certo limite de tempo,
proporcional aos tamanhos da entrada e da saída.
Iremos chamar estas funções de \emph{construtíveis}.

A literatura diverge nas definições para função construtível.

Uma função $f$ é \emph{espaço"=construtível}
\footnote{
    Do inglês ``space"=constructible''.
}, para
\citeonline[p. 297]{HopcroftUllman1979},
caso exista uma máquina de Turing que,
ao receber $x$ na entrada,
ocupe, no máximo, $f(|x|)$ células da fita;
e que, para todo $n$, exista ao menos algum $x$ de tamanho $n$
em que a máquina ocupe exatamente $f(n)$ células.
Esta função é \emph{totalmente espaço"=construtível}
se a máquina ocupa $f(n)$ células em todas as palavras de tamanho $n$.

Analogamente, uma função $f$ é \emph{tempo"=construtível}
\footnote{
    Do inglês ``time"=constructible''.
}, para
\citeonline[p. 299]{HopcroftUllman1979},
caso exista uma máquina de Turing que,
ao receber $x$ na entrada,
efetue, no máximo, $f(|x|)$ movimentos antes de aceitar ou rejeitar $x$;
e que, para todo $n$, exista ao menos algum $x$ de tamanho $n$
em que a máquina faça exatamente $f(n)$ movimentos.
Esta função é \emph{totalmente tempo"=construtível}
se a máquina efeuta $f(n)$ movimentos em todas as palavras de tamanho $n$.

Observe que,
em ambas as definições,
não é exigido que a máquina ``compute'' função alguma;
por exemplo,
uma máquina que meramente leia a entrada por completo antes de aceitar
é suficiente para demonstrar que a função $f(n) = n+1$
é totalmente tempo"=construtível.

As exigências impostas por \citeonline{HopcroftUllman1979}
são bastante restritivas.
Por exemplo,
podemos extender a demonstração da proposição
\ref{regularidade_tempo_sublinear}
para mostrar que a função $f(n) = n$
não é tempo"=construtível;
basta ver que a máquina precisa de ao menos $n+1$ movimentos
para chegar ao primeiro branco e decidir parar.

De fato, qualquer função $f$ tal que $f(n_0) \leq n_0$ para algum $n_0$
não satisfaz à definição de ``tempo"=construtível''
\footnote{
    Isso introduz o problema de que o conjunto das funções tempo"=construtíveis
    passa a não ser fechado sob multiplicação por escalar.
}
--- o que, de certa forma,
é compatível com a suposição feita por \citeonline[p. 287]{HopcroftUllman1979}
de que $f(n) \geq n+1$
quando $f$ for usada no contexto de complexidade de tempo.
