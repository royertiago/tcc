\section{Teoria de Complexidade Axiomática: Axiomas de Blum}
\label{sec:blum_axioms}

\begin{definition}
    Seja $\phi$ uma enumeração de Gödel aceitável.
    Uma \emph{medida de complexidade} é uma função
    $\Phi: \{0, 1\}^* \times \{0, 1\}^* \to \mathbb N$,
    que satisfaz aos seguintes axiomas:\footnotemark
    \begin{enumerate} [label=\textbf{Axioma \arabic*}, ref=\arabic*, align=left]
        \item
            \label{ax:blum_def}
            $\Phi(x, y)$ está definido
            se, e somente se,
            $\phi_x(y)$ está definido.
        \item
            \label{ax:blum_rec}
            A função $R(x, y, m)$,
            definida como $1$ se $\Phi(x, y) = m$,
            e $0$ caso contrário,
            é recursiva total.
    \end{enumerate}

    \footnotetext{
        A definição original de \citeonline[p.~3]{Blum1967}
        é dada no contexto do cálculo de funções de inteiros.
        Em particular,
        as enumerações de Gödel aceitáveis são indexadas por números,
        não por cadeias de $\{0, 1\}^*$.
        Esta adaptação é baseada na definição de \citeonline[p.~156]{Papadimitriou1994}.
    }
\end{definition}

O axioma~\ref{ax:blum_rec}
nos dá um semialgoritmo para calcular $\Phi(x, y)$.
Entretanto, pelo axioma~\ref{ax:blum_def},
não podemos ir muito além disso,
pois $\phi_x(y)$ não está definido para todo $x$ e $y$.
(De fato, decidir se $\Phi(x, y)$ existe
é exatamente o problema da parada para o modelo de computação de $\phi$.)

Nos exemplos que se seguem,
quando estivermos usando a enumeração de Gödel $f_x$,
utilizaremos a notação $\Phi(\langle M \rangle, x)$
para nos referir a $\Phi(w, x)$,
em que $w$ é a codificação (em binário) da máquina $M$.
Não há problemas de ambiguidade,
pois a codificação $w = \langle M \rangle$ como definida
identifica a função $f_w$ unicamente.

\begin{example}
    \label{ex:time_complexity}
    \simbolo{$\PhiDT$}{Complexidade de Tempo}
    A \emph{complexidade de tempo},
    que denotaremos por $\PhiDT$,
    é a função que diz quantos movimentos
    uma máquina de Turing faz até retornar uma resposta.
    Isto é,
    \begin{equation*}
        \PhiDT( \langle M \rangle, x ) = \begin{cases}
            k, & \text{
                \parbox{0.6\textwidth}{
                    se $M$ executa exatamente $k$ passos em $x$ antes de parar.
                }
            } \\
            \text{indefinido}, & \text{
                \parbox{0.6\textwidth}{
                    caso $M$ nunca pare de computar $x$.
                }
            }
        \end{cases}
    \end{equation*}
    Para determinar se $\PhiDT( \langle M \rangle, x) = k$,
    execute a máquina $M$ por $k$ passos
    e veja se é a primeira vez que
    $M$ atinge um estado aceitador.
    E, como $\PhiDT( \langle M \rangle, x)$ só está definido se $M$ para ao computar $x$,
    $\PhiDT$ satisfaz aos dois axiomas de Blum.
\end{example}

\begin{example}
    \label{ex:space_complexity}
    \simbolo{$\PhiDS$}{Complexidade de Espaço}
    Para a \emph{complexidade de espaço},
    que denotaremos por $\PhiDS$,
    assumiremos que $M$ possui uma fita somente"=leitura
    específica para a entrada.
    \begin{equation*}
        \PhiDS( \langle M \rangle, x) = \begin{cases}
            k, & \text{
                \parbox{0.6\textwidth}{
                    se~$M$ para ao computar~$x$,
                    tendo lido exatamente~$k$ células
                    de uma de suas fitas de trabalho
                    e no máximo $k$~células nas demais fitas.
                }
            } \\
            \text{indefinido}, & \text{
                \parbox{0.6\textwidth}{
                    se $M$ nunca parar ao computar $x$.
                }
            }
        \end{cases}
    \end{equation*}
    Precisamos desta definição intrincada
    pois~$M$ pode não ler $k$~células de todas as suas fitas,
    apenas de algumas.

    Claramente o axioma~\ref{ax:blum_def} é satisfeito.
    Para o axioma~\ref{ax:blum_rec},
    o algoritmo é um pouco mais complicado.

    Comece executando $M$ em $x$.
    Caso $M$ extrapole $k$ células lidas
    em alguma de suas fitas,
    podemos rejeitar a entrada
    (isto é, $\Phi(\rangle M \langle, x) = k$ é falso).
    Caso contrário,
    existirá um número finito de configurações da máquina.

    Existem~$|\Gamma|^k$ possíveis fitas com $k$ termos
    e $k+1$ possíveis posições da cabeça de leitura;
    teremos, portanto,
    $(k+1)|\Gamma|^k$~diferentes configurações para cada fita.
    Para $l$ diferentes fitas e $|Q|$~possíveis estados da máquina,
    existem, no máximo,
    \begin{equation}
        |Q| \left((k+1)|\Gamma|^k\right)^l
        \label{eq:configurations_count}
    \end{equation}
    possíveis configurações.
    Portanto, se a máquina executar
    mais movimentos do que este número,
    significa que ela entrou em loop.
    Podemos rejeitar a entrada.%
    \footnote{
        Este cuidado adicional é imprescindível
        para garantir que o predicado
        ``$\Phi(\langle M \rangle, x) = k$''
        seja decidível,
        não apenas semidecidível.

        Note que precisamos rejeitar a entrada
        caso a máquina entre em loop
        porque $\Phi( \langle M \rangle, x)$ só está definido
        quando $M(x)$ está
        --- não é o caso se $M$ entra em loop
        ao computar $x$.
    }

    E, por último,
    caso $M$ pare,
    precisamos nos assegurar que,
    de fato,
    em alguma das fitas $k$ células foram lidas.
\end{example}

\begin{example}
    \label{ex:nondeterministic_complexity}
    \simbolo{$\PhiNT$}{Complexidade de Tempo não"=determinística}
    \simbolo{$\PhiNS$}{Complexidade de Espaço não"=determinística}
    Podemos adaptar $\PhiDT$ e $\PhiDS$
    para máquinas de Turing não"=determinísticas.%
    \footnote{
        Tecnicamente,
        as denominações usuais,
        ``complexidade de tempo/espaço não"=determinística''
        ou ``tempo/espaço não"=determinístico''
        estão erradas;
        não é o tempo ou espaço ou a complexidade que são não"=determinísticos,
        mas sim o modelo de máquina ao qual nos referimos.

        Entretanto, toleraremos este abuso de nomenclatura neste texto.
    }

    A complexidade de tempo não"=determinística,
    que denotaremos por $\PhiNT(\langle M \rangle, x)$,
    definiremos como sendo a maior quantidade de movimentos
    tomadas por $M$ ao computar $x$
    dentre todas as escolhas de transições possíveis.

    Analogamente,
    definiremos a complexidade de espaço não"=determinística,
    que denotaremos por $\PhiNS(\langle M \rangle, x)$,
    como sendo a maior quantidade de células lidas
    em qualquer dos ramos da computação de $M$ em $x$.
    Aqui, precisamos tomar o mesmo cuidado que tomamos
    com $\PhiDS$ para demonstrar o axioma~\ref{ax:blum_rec}.
\end{example}

Nos exemplos \ref{ex:time_complexity} e~\ref{ex:space_complexity},
a enumeração utilizada é a $f_x$
definida na seção~\ref{sec:definition_enumeration_of_recursive_functions}.
No exemplo~\ref{ex:nondeterministic_complexity},
ficou faltando definir a enumeração de Gödel associada;
isto é, jogamos o problema de
explicar como uma máquina não"=determinística computa uma função
para ``debaixo do tapete''.
Voltaremos a este problema no capítulo~\ref{ch:nondeterministic_functions}.
Por ora,
será suficiente nos restringirmos às funções booleanas,
usando a mesma definição usada para decisores.

\begin{example}
    Escolher $\Phi(w, x) = 0$ para todo $M$ e $x$
    satisfaz ao axioma~\ref{ax:blum_rec},
    mas não ao axioma~\ref{ax:blum_def},
    pois $\Phi(w, x)$ está definida mesmo quando $f_w(x)$ não está.
    Já definir $\Phi(w, x) = |f_w(x)|$
    satisfaz ao axioma~\ref{ax:blum_def},
    mas não ao axioma~\ref{ax:blum_rec},
    pois poderíamos resolver o problema da parada:
    dada uma máquina $M$, podemos modificá"=la
    para apagar sua fita logo antes de parar.
    Então, para esta $M'$,
    $\Phi(\langle M' \rangle, x) = 0$ se, e somente se,
    a $M$ original para ao computar $x$.
    Estes dois exemplos mostram que os axiomas são independentes
    \cite[p.~3]{Blum1967}.
\end{example}

Podemos ver que as medidas $\PhiDT$ e $\PhiDS$ estão relacionadas.
Para ler uma posição da fita,
é necessário gastar ao menos uma unidade de tempo.
Ou seja,
\begin{equation*}
    \PhiDS(\langle M \rangle, x) \leq \PhiDT(M, x).
\end{equation*}
E, de acordo com o raciocínio do exemplo~\ref{ex:space_complexity},
para todo $M$ existe algum $c$ que
\begin{equation*}
    \PhiDT(\langle M \rangle, x) \leq c^{\PhiDS(M, x)}.
\end{equation*}
De fato, podemos relacionar quaisquer duas medidas de complexidade.

\begin{theorem}
    \label{thm:measure_related}
    Dada uma enumeração de Gödel aceitável $\phi$
    e duas medidas de complexidade $\Phi$ e $\hat \Phi$ para $\phi$,
    existe uma função recursiva $r$ tal que
    \begin{equation*}
        \Phi(w, x) \leq r( x, \hat \Phi(w, x))
    \end{equation*}
    para todo $w$ e quase todo $x$.%
    \footnote{
        Um predicado é ``verdadeiro para quase todo $n$''
        quando ele é falso para apenas uma quantidade finita de números $n$.
        Equivalentemente,
        é quando existe algum $n_0$ tal que
        o predicado é válido para todo $n > n_0$.
    }
\end{theorem}

\begin{proof}
    Defina
    \begin{equation*}
        r( x, k ) = \max \{ \Phi(w, x) \mid |w| \leq |x| \land \hat \Phi(w, x) = k \}
    \end{equation*}
    Fixado $x$, existe um número finito de máquinas de Turing
    cuja descrição é menor que $|x|$.
    O conjunto na definição acima é um subconjunto desta lista
    (pois, além da exigência $|w| \leq |x|$,
    exigimos que $\hat \Phi(w, x) = k$.)

    O predicado $\hat \Phi(w, x) = k$ é recursivo.
    Quando este predicado é verdadeiro,
    $\phi_w(x)$ está definido, pelo axioma~\ref{ax:blum_def},
    portanto $\Phi(w, x)$ também está definido e pode ser calculado.
    Concluímos que $r$ é recursiva.

    Agora, para todos os $x$ que são mais longos que $w$,
    $\Phi(w, x)$ será um dos elementos do conjunto acima
    para $r(x, \hat \Phi(w, x))$,
    portanto é menor ou igual a $\Phi(w, x)$.
\end{proof}

\citeonline[p.~4]{Blum1967} demonstra uma versão ligeiramente mais forte
deste teorema.
Ele prova que $r$ pode ser tal que,
simultaneamente,
\begin{equation*}
    \Phi(w, x) \leq r( x, \hat \Phi(w, x))
\end{equation*}
e
\begin{equation*}
    \hat \Phi(w, x) \leq r( x, \Phi(w, x))
\end{equation*}
Podemos construir uma função dessas
pegando o máximo de duas funções obtidas
usando o teorema~\ref{thm:measure_related}.

O teorema,
assim como provamos,
não pode ser fortalecido
para que $r$ seja uma função de apenas uma variável.
Considere $A$ uma máquina de Turing
que opere como um autômato finito.
$\PhiDT(\langle A \rangle, x) = |x|$ para toda palavra $x$,
enquanto que $\PhiDS(\langle A \rangle, x) = 1$ para toda palavra $x$.%
\footnote{
    A complexidade de espaço não é $0$
    pois $A$ é obrigada a ler
    ao menos a célula inicial da sua fita de trabalho,
    embora a máquina não use aquela célula.
}
Se $r$ pudesse depender apenas da segunda variável,
isto é, $r(x, k) = r'(m)$ para alguma função $r'$,
teríamos
\begin{align*}
    |x| &= \PhiDT(\langle A \rangle, x) \\
        &\leq r(x, \PhiDS(\langle A \rangle, x)) \\
        &= r(x, 1) \\
        &= r'(1)
\end{align*}
que é falso para todo $x$ suficientemente comprido.

Caso $r$ pudesse depender apenas da primeira variável,
isto é, $r(x, k) = r''(x)$ para alguma função $r''$,
teríamos, para todas as máquinas de Turing,
\begin{equation*}
    \PhiDT(\langle M \rangle, x) \leq r''(x).
\end{equation*}
Mas, como $r''$ é recursiva
(pois $r$ o é),
podemos construir uma máquina que calcula $r''(x)$,
desperdiça $r''(x)$ movimentos,
e aceita a entrada.
Para esta $M'$,
\begin{equation*}
    \PhiDT(\rangle M' \langle, x) > r''(x),
\end{equation*}
contradizendo a equação anterior.

No parágrafo anterior,
construímos uma máquina de Turing
que deliberadamente desperdiça tempo
ao computar determinada função.
\citeonline[p.~4]{Blum1967} demonstrou que
é sempre possível desperdiçar recursos computacionais,
quaisquer que sejam estes recursos.
Precisamos de um lema,
vindo direto da teoria das funções recursivas.

\begin{lemma}[Teorema da Recursão]
    Para qualquer enumeração de Gödel aceitável $\phi$
    e qualquer função recursiva total $\sigma$,
    existe um valor $w$ tal que
    \begin{equation*}
        \phi_w(x) = \phi_{\sigma(w)}(x)
    \end{equation*}
    para todo $x$.
    (Tal valor é chamado de \emph{ponto fixo} para $\sigma$.)
    \label{thm:recursion}
\end{lemma}

\begin{proof}
    Ilustraremos o teorema com o caso $\phi_x = f_x$.
    %TODO: Demonstrar por completo.

    Primeiro, construiremos uma máquina $M$ que,
    ao receber $x$ na entrada,
    computará uma máquina equivalente a $\phi_x(x)$.
    Isto é, para todo $y$,
    \begin{equation}
        \phi_{M(x)}(y) = \phi_{f_x(x)}(y),
        \label{eq:diagonal_N}
    \end{equation}
    sempre que $f_x(x)$ existir.
    \footnotetext{
        Duas palavras $u$ e $v$ são equivalentes
        se, para todo $x$, $f_u(x) \simeq f_v(x)$.
    }

    A abordagem direta,
    calcular $\phi_x(x)$,
    não funciona,
    pois $\phi_x(x)$ pode não existir.
    pois a máquina representada por $x$ pode nunca parar ao processar $x$.

    Observe que não precisamos retornar $M_x(x)$,
    e sim, apenas uma máquina equivalente a $M_x(x)$,
    caso $M_x(x)$ exista.
    Na entrada $x$, $N$ retornará uma máquina que,
    ao receber $y$ na entrada,
    compute $M_x(x)$,
    e, somente após $M_x$ retornar,
    rode $M_x(x)$ em $y$
    (usando uma máquina de Turing universal).

    É importante notar que $N$ sempre pára;
    $M_x(x)$ pode não parar ao computar $x$,
    mas isso significa, apenas,
    que $N(x)$ nunca parará ao computar qualquer coisa
    --- o valor $N(x)$ existirá.

    De posse da máquina $N$, podemos prosseguir.
    Escolha $k$ como sendo um índice para $\sigma \circ N$.
    Isto é,
    \begin{equation}
        M_k(x) = \sigma(N(x))
        \label{eq:k_sigma_N}
    \end{equation}
    para todo $x$.
    Afirmamos que $m = N(k)$
    satisfaz às exigências do teorema.

    De fato,
    \begin{align*}
        M_m(x) &= M_{N(k)}(x) \\
               &= M_{M_k(k)}(x) && \text{Pela equação~\ref{eq:diagonal_N}}\\
               &= M_{\sigma(N(k))}(x) && \text{Pela equação~\ref{eq:k_sigma_N}}\\
               &= M_{\sigma(m)}(x) && \text{Pela definição de $m$.}
    \end{align*}
\end{proof}

\begin{proposition}
    Seja $\phi$ uma numeração de Gödel aceitável,
    $\Phi$ uma medida de complexidade para $\phi$,
    e $f$ e $g$ funções recursivas totais.
    (Interpretaremos $g$ como sendo uma função de inteiros.)
    Então existe um índice $w$ para a função $f_w$ tal que
    \begin{equation*}
        \Phi(w, x) > g(\langle|x|\rangle)
    \end{equation*}
    para todo $x$.
    \label{thm:resource_waste}
\end{proposition}

Ou seja,
o dispositivo computacional representado por $w$
desperdiça mais de $g(n)$ unidades do recurso medido por $\Phi$
ao processar uma palavra de tamanho $n$.
Em outras palavras,
código ruim pode ser feito em qualquer linguagem.

\begin{proof}
    Defina a função $h$, de duas variáveis, por
    \begin{equation*}
        h(w, x) = \begin{cases}
            \phi_w(x)1 & \text{se $\Phi(w, x) \leq g(\langle|x|\rangle)$} \\
            f(x) & \text{caso contrário.}
        \end{cases}
    \end{equation*}
    ($\phi_w(x)a$ é o valor de $\phi_w(x)$ concatenado com o símbolo $1$.)

    Observe que $h$ é uma função computável,
    pois $\Phi$, $g$ e $f$ o são,
    e, caso $\Phi(w, x)$ esteja definido,
    $\phi_w(x)$ também estará.

    Seja $S$ a função $S_{mn}$ da enumeração $\phi$,
    e $v$ um índice para $h$.
    Construa a função $\sigma$ que,
    na entrada $w$, calcula $S(v, w)$
    --- isto é, $\sigma(w) = S(v, w)$.
    Portanto,
    \begin{equation*}
        \phi_{\sigma(w)}(x) = \phi_{S(v, w)}(x) = \phi_v(\langle w, x \rangle) = h(w, x).
    \end{equation*}
    Observe que $\sigma$ é recursiva total, pois $S$ o é.

    Pelo teorema da recursão (lema~\ref{thm:recursion}),
    $\sigma$ possui um ponto fixo $w_0$.
    Demonstraremos que $w_0$ satisfaz às exigências do teorema.

    Caso a função $h$, ao computar o valor de $h(w_0, x)$
    para algum $x$,
    tenha escolhido a primeira cláusula,
    a saída final de $\sigma(w_0)$ teria sido
    $\phi_{w_0} (x)$ concatenado com $1$,
    que é diferente de apenas $\phi_{w_0}(x)$.
    Portanto, $w_0$ não seria um ponto fixo de $\sigma$,
    contradizendo o teorema da recursão.

    Portanto, $h$ nunca seleciona a primeira cláusula
    ao computar $h(w_0, x)$, para qualquer $x$.
    Isto significa que $\Phi(w_0, x) > g(\langle |x| \rangle)$ para todo $x$,
    o que garante a exigência de complexidade,
    e que
    \begin{equation*}
        \phi_{\sigma(w_0)}(x) = f(x).
    \end{equation*}
    Mas, como $w_0$ é um ponto fixo de $\sigma$,
    a própria $w_0$ já computava $f$ antes de passar por $\sigma$,
    o que prova a exigência da função.
\end{proof}
