\section{Enumeração de Funções Recursivas}
\label{sec:enumeration_of_recursive_functions}

\subsection{Funções Recursivas}

Usualmente,
``máquina de Turing'' é definida como uma tupla
na qual um de seus elementos,
$\Sigma$,
denota o alfabeto de entrada.
Por simplicidade,
assumiremos que $\Sigma = \{0, 1\}$,
em todo o TCC.
Observe que não há perda de generalidade nesta definição,
pois outros alfabetos podem ser codificados de forma não"=ambígua
usando apenas este alfabeto binário.

\begin{notation}
    Seja $M$ uma máquina de Turing determinística
    e $x \in \{0, 1\}^*$ uma palavra.
    Suponha que $M$ pare ao computar $x$.
    Se o conteúdo deixado na fita por $M$,
    após remover os caracteres brancos à direita e à esquerda,
    contiver apenas os símbolos $0$ e $1$
    (isto é, não houverem brancos ou outros símbolos de fita),
    este conteúdo forma uma palavra de $\{0, 1\}^*$.
    Denotaremos esta palavra por $M(x)$.
    Caso haja outros símbolos na fita
    ou $M$ não parar ao computar $x$,
    deixaremos $M(x)$ indefinido.
\end{notation}

Observe que a notação $M(x)$ coincide com a notação de chamada de função.
É exatamente esta a analogia que pretendemos fazer;

\begin{definition}
    \label{def:recursive_function}
    Seja $M$ uma máquina de Turing.
    A \emph{função computada por $M$}
    é a função parcial $f: \{0, 1\}^* \to \{0, 1\}^*$
    tal que $f(x)$ está definida se e somente se $M(x)$ existe,
    e, nestes casos, $f(x) = M(x)$.

    Uma função $f$ é \emph{recursiva parcial}
    se for computada por alguma máquina $M$.
    Se $f$ estiver definida para todo $x \in \{0, 1\}^*$,
    dizemos que $f$ é \emph{recursiva total}.
    \footnote{
        Não confundir com o conceito de \emph{recursão} em linguagens de programação.
    }
\end{definition}
(Esta definição é uma variação da definição de \citeonline[p.~151]{HopcroftUllman1979};
em particular, utilizaremos funções que mapeiam palavras para palavras
em vez de funções que mapeiam números naturais para números naturais.)

\subsubsection{Codificação de objetos}
\label{sec:binary_encoding}

Conforme observado por \citeonline[p.~2]{AroraBarak2009},
não perdemos generalidade restringir funções a palavras de $\{0, 1\}^*$,
pois podemos codificar objetos matemáticos complexos usando o sistema binário
--- de fato,
é exatamente isso o que fazemos nos computadores modernos.
Podemos, por exemplo,
codificar inteiros usando sua representação binária,
e grafos podem ser representados por sua matriz de adjacência
ou pelos pares de nodos adjacentes.
\citeonline[p.~10]{GareyJohnson1979} argumentam que
não é necessário se ater aos detalhes da representação dos objetos,
pois quaisquer duas codificações ``razoáveis'' destes objetos
irão diferir polinomialmente de tamanho.

Neste trabalho,
dois objetos aparecerão mais frequentemente:
máquinas de Turing e tuplas.
Uma máquina de Turing pode ser representada em binário
listando todos elementos da função de transição
\cite[p.~182]{HopcroftUllman1979};
os detalhes estão no apêndice~\ref{app:turing_machines}.
Denotaremos por $\langle M \rangle$ a representação em binário da máquina $M$.

Já uma tupla $(x_1, x_2, \dots, x_n)$ pode ser codificada
combinando as representações em binário de $x_1, \dots, x_n$.
A ideia é trocar, nas representações em binário,
$0$ por $00$ e $1$ por $01$;
então, a cadeia $1$ faz o papel de separador.
Denotaremos por $\langle x_1, x_2, \dots, x_n \rangle$
a representação binária da tupla $(x_1, x_2, \dots, x_n)$.
Observe que esta codificação é não"=ambígua;
podemos recuperar a representação em binário de cada um dos $x_i$
a partir de $\langle x_1, \dots, x_n \rangle$.

\begin{example}
    Podemos representar o número $2$ por $10$ e o número $5$ por $101$,
    em binário.
    A transformação mencionada acima troca $10$ por $0100$
    e $101$ por $010001$;
    portanto, a tripla ordenado $(2, 5, 2)$ é representada por
    \begin{equation*}
        \langle 2, 5, 2 \rangle = 0100\ 1\ 010001\ 1\ 0100.
    \end{equation*}
\end{example}

\simbolo{$\langle x \rangle$}{Codificação em binário do objeto matemático $x$}
(Em geral, $\langle x \rangle$ denotará a representação em binário
do objeto matemático $x$.
\citeonline[p.~2]{AroraBarak2009} usa
$\sideset{_\llcorner}{_\lrcorner}{\mathop{\makebox[0.5ex]{$x$}}}$
para o mesmo fim;
eu escolhi a notação $\langle x \rangle$
por conformidade com a notação de \citeonline[p.~182]{HopcroftUllman1979}.)

% Explicando o comando acima:
% \sideset permite adicionar símbolos matemáticos "orbitando" o símbolo subsequente
% nos quatro cantos possíveis. (O primeiro argumento diz o que vai à esquerda
% e o segundo argumento diz o que vai à direita.)
% \sideset exige que o terceiro argumento seja um operador matemático,
% que eu obtenho usando \mathop.
% Mas se for usado "\mathop x" diretamente, as duas marcas sob x
% ficarão muito espaçadas; então, a largura do x é alterada artificialmente
% para 0.5ex usando o \makebox.

\subsubsection{Funções de várias variáveis}

Observe que o termo ``função recursiva''
foi definido apenas para funções de uma variável.
Entretanto,
em alguns pontos do texto,
precisaremos nos referir a funções de mais de uma variável.

É possível estender as máquinas de Turing
para trabalhar diretamente com com funções de várias variáveis.
Por exemplo, \citeonline[p.~151]{HopcroftUllman1979}
fazem a extensão no contexto de funções de inteiros.
Dada uma máquina $M$,
para calcular o valor de $M(i)$,
executamos $M$ na entrada $0^i$.
Os vários argumentos são separados por caracteres $1$;
isto é, para calcular $M(i_1, i_2, \dots, i_k)$,
executamos $M$ na entrada $0^{i_1} 1 0^{i_2} 1 \dots 1 0^{i_k}$.

Para não precisar alterar a definição de máquinas de Turing,
recorreremos à codificação $\langle \cdot \rangle$,
definida na seção~\ref{sec:binary_encoding}.

\begin{definition}
    Uma função parcial $f: (\{0, 1\}^*)^k \to \{0, 1\}^*$ é \emph{recursiva parcial}
    se existir alguma função recursiva parcial $g: \{0, 1\}^* \to \{0, 1\}^*$
    tal que $g(\langle i_1, i_2, \dots, i_k \rangle)$
    está definida se, e somente se, $f(i_1, i_2, \dots, i_k)$ está definida,
    e, neste caso,
    \begin{equation*}
        g(\langle i_1, i_2, \dots, i_k \rangle) = f(i_1, i_2, \dots, i_k).
    \end{equation*}
    Funções recursivas totais são definidas analogamente.
\end{definition}

Observe que esta definição não é autorreferencial
pois a recursividade de $g$ é estabelecida na definição~\ref{def:recursive_function}.

\subsection{Enumeração de Funções Recursivas}
\label{sec:definition_enumeration_of_recursive_functions}

A existência de uma codificação em binário de máquinas de Turing
permite, de certa forma,
enumerar todas as funções recursivas parciais
--- basta listar todos os códigos possíveis para máquinas de Turing.
Estritamente falando,
não é as funções que estão sendo listadas
(isso seria impossível pois funções são objetos matemáticos infinitos),
mas sim códigos em binário para máquinas que as computam.

A construção da codificação das máquinas de Turing não é ``injetora'';
isto é, existem máquinas $M$ e $N$ diferentes
tais que
\begin{equation*}
    \langle M \rangle = \langle N \rangle.
\end{equation*}
Entretanto,
a construção foi feita de forma que
as funções computadas por $M$ e $N$ coincidam
sempre que a equação acima for satisfeita.
Portanto,
dada uma cadeia $x \in \{0, 1\}^*$,
existe uma única função recursiva parcial
que é computada pelas máquinas cuja codificação em binário é $x$.
Chamaremos esta função de $f_x$.
Observe que o mapeamento $x \mapsto f_x$
enumera todas as funções recursivas;
as seções \ref{sec:universal_turing_machine} e~\ref{sec:s_m_n_theorem}
contém teoremas que nos permitem trabalhar com as funções $f_x$
e a seção~\ref{sec:acceptable_godel_numbering}
define o conceito de ``Enumeração de Gödel aceitável'',
que generaliza este mapeamento.
\simbolo{$f_x$}{Função computada pela máquina codificada por $x$}

\subsection{Teorema da Máquina Universal}
\label{sec:universal_turing_machine}

Durante a demonstração da indecidibilidade do problema da parada,
é construída uma máquina de Turing universal,
que é capaz de simular qualquer outra máquina de Turing,
bastando apenas lhe ser fornecida uma representação da máquina de Turing simulada.
(De certa forma,
os computadores modernos são máquinas de Turing universais.)
Podemos sintetizar esta construção através do mapeamento de funções recursivas
definido na seção anterior.

\begin{theorem}
    Existe uma função recursiva parcial $g$ de duas variáveis tal que
    $g(x, y)$ existe se, e somente se, $f_x(y)$ existe,
    e, neste caso,
    \begin{equation*}
        g(x, y) = f_x(y).
    \end{equation*}
\end{theorem}

\begin{proof}
    A função $g$ é a função computada por uma máquina de Turing universal.
    Em nosso caso,
    a máquina universal $U$,
    na entrada $\langle x, y \rangle$,
    usará a tabela de transições disponível em $x$
    para executar as etapas de computação de alguma máquina $M$
    que satisfaz $\langle M \rangle = x$.
    $x$ é a codificação binária de $M$;
    portanto,
    ao simular as etapas de computação de $M$ em $y$,
    $U$ estará, efetivamente,
    calculando o valor de $f_x$ (que é a função computada por $M$).

    $f_x(y)$ só não está definida se $M$ nunca parar ao processar $y$;
    neste caso, $U$ também não parará ao processar $\langle x, y \rangle$.
    Caso contrário,
    após a simulação chegar a um estado final,
    basta que $U$ escreva a ``resposta'' de $M$ na saída.
    Como a resposta de $M$ é $M(y) = f_x(y)$,
    obtemos a igualdade $g(x, y) = f_x(y)$.
\end{proof}

\subsection{Teorema $S_{mn}$}
\label{sec:s_m_n_theorem}

\begin{theorem}
    Existe uma função recursiva total $\sigma$ de duas variáveis tal que,
    para todo $x, y, z \in \{0, 1\}^*$,
    $f_x( \langle y, z \rangle )$ está definido se, e somente se,
    $f_{\sigma(x, y)}(z)$ está definido, e,
    neste caso,
    \begin{equation*}
        f_{\sigma(x, y)}(z) = f_x(y, z).
    \end{equation*}
\end{theorem}

Isto é,
dado um índice $x$ para a função de duas variáveis $f_x$
e uma palavra $y$ qualquer,
a função $\sigma$ devolve uma máquina de Turing $M$
(quer dizer, $\langle M \rangle = \sigma(x, y)$)
que, na entrada $z$,
calcula o valor $f_x(y, z)$.

Em outras palavras,
a função $\sigma$ deixa o primeiro argumento da função $f_x$
fixo em $y$.
Esta versão do teorema
(mencionada por \citeonline[p.~3]{Blum1967})
lida apenas com o caso de fixar uma entrada ($y$)
e deixar uma entrada livre ($z$).
A ``versão completa'' do teorema
está presente no livro de \citeonline[p.~23]{Rogers1987};
ele diz como transformar uma função de $m + n$ variáveis
numa função de $n$ variáveis
fixando as $m$ primeiras para valores pré"=estabelecidos.

Entretanto, para nossos propósitos,
esta versão será suficiente.

\begin{proof}
    Dado $x$ e $y$ na entrada,
    $\sigma$ terá de retornar uma representação de uma máquina de Turing.
    A função $\sigma$ é total,
    o que significa que $\sigma(x, y)$ sempre existirá;
    entretanto,
    pode ser que a máquina $\sigma(x, y)$ não pare em todas as entradas.

    Se $M = \sigma(x, y)$,
    a ideia é fazer com que $M$ substitua a entrada $z$ por $\langle y, z \rangle$,
    e execute a máquina representada por $x$ no resultado.
    Para isso,
    basta embutir em $M$ o valor $y$ e as transições de $x$.

    Esta construção pode ser executada para todo $x$ e $y$,
    tornando $\sigma$ uma função recursiva total.
    A máquina $M$ representada por $\sigma(x, y)$ executará,
    na entrada $z$, a máquina $x$ em $\langle y, z \rangle$;
    portanto,
    $M(z)$ estará definido se, e só se, $f_x(\langle y, z \rangle)$ está definido;
    e, nestes casos,
    \begin{equation*}
        M(z) = f_x( \langle y, z \rangle ).
    \end{equation*}
    Mas como $\langle M \rangle = \sigma(x, y)$,
    a função calculada por $M$ é, exatamente, $f_{\sigma(x, y)}$,
    o que prova o teorema.
\end{proof}

\subsection{Enumerações de Gödel aceitáveis}
\label{sec:acceptable_godel_numbering}

De posse dos teoremas da máquina universal e $S_{mn}$,
podemos definir as restrições sob as quais definiremos os axiomas de Blum.

\begin{definition}
    Seja $\mathcal P$ o conjunto de todas as funções recursivas parciais.
    Uma \emph{enumeração de Gödel aceitável}
    é uma função $\phi: \{0, 1\}^* \to \mathcal P$, sobrejetora,
    que satisfaz às conclusões do teorema da máquina universal
    e do teorema $S_{mn}$.
    (\citeauthor{Rogers1987}, \citeyear{Rogers1987}, p.~41;
    \citeauthor{Blum1967}, \citeyear{Blum1967}, p.~3)
    % TODO: Descobrir como citar dois autores separadamente,
    % incluindo os números de páginas para ambos.
\end{definition}

Uma enumeração de Gödel aceitável é uma função $\phi$ que associa
cada cadeia de $\{0, 1\}^*$ a uma função recursiva parcial.
Como $f$ é sobrejetora,
o contrário também acontece:
toda função recursiva parcial é ``enumerada'' por $\phi$.
Denotaremos $\phi(x)$ por $\phi_x$.

Por ``satisfazer às conclusões do teorema da máquina universal''
quer"=se dizer que,
para esta enumeração $\phi$,
existe alguma função recursiva parcial $g$, de duas variáveis,
tal que $g(x, y)$ está definido se, e somente se, $\phi_x(y)$ está definido,
e, neste caso,
\begin{equation*}
    g(x, y) = \phi_x(y).
\end{equation*}
Similarmente, por ``satisfazer ao teorema $S_{mn}$'' queremos dizer que
existe alguma função recursiva total $\sigma$ de duas variáveis
tal que $\phi_{\sigma(x, y)}(z)$ está definido se,
e somente se, $\phi_x(\langle x, y \rangle)$ está definido,
e, neste caso,
\begin{equation*}
    \phi_{\sigma(x, y)}(z) = \phi_x(\langle x, y \rangle).
\end{equation*}

\begin{example}
    O mapeamento $x \mapsto f_x$,
    definido na seção~\ref{sec:definition_enumeration_of_recursive_functions},
    é uma enumeração de Gödel aceitável.
\end{example}

Podemos pensar nas enumerações de Gödel aceitáveis
como mapeamentos semânticos;
são regras que atribuem a cada cadeia de $\{0, 1\}^*$
uma função de $\mathcal P$.
Portanto,
cada modelo de computação equivalente à máquina de Turing
induz uma função enumeração de Gödel aceitável.
Computacionalmente,
não podemos trabalhar diretamente com as enumerações,
pois são estruturas infinitas;
as restrições adicionais
(possuir uma função universal e satisfazer ao teorema $S_{mn}$)
nos permite trabalhar com estas enumerações indiretamente.
