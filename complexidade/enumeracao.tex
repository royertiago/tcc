\section{Enumerações de Funções Recursivas}
\label{sec:enumerations_of_recursive_functions}

\subsection{Funções Recursivas}

Usualmente,
``máquina de Turing'' é definida como uma tupla
na qual um de seus elementos,
$\Sigma$,
denota o alfabeto de entrada.
Por simplicidade,
assumiremos que $\Sigma = \{0, 1\}$,
em todo o TCC.
Observe que não há perda de generalidade nesta definição,
pois outros alfabetos podem ser codificados de forma não"=ambígua
usando apenas este alfabeto binário.

\begin{notation}
    Seja $M$ uma máquina de Turing determinística
    e $x \in \{0, 1\}^*$ uma palavra.
    Suponha que $M$ pare ao computar $x$.
    Se o conteúdo deixado na fita por $M$,
    após remover os caracteres brancos à direita e à esquerda,
    contiver apenas os símbolos $0$ e $1$
    (isto é, não houverem brancos ou outros símbolos de fita),
    este conteúdo forma uma palavra de $\{0, 1\}^*$.
    Denotaremos esta palavra por $M(x)$.
    Caso haja outros símbolos na fita
    ou $M$ não parar ao computar $x$,
    deixaremos $M(x)$ indefinido.
\end{notation}

Observe que a notação $M(x)$ coincide com a notação de chamada de função.
É exatamente esta a analogia que pretendemos fazer;

\begin{definition}
    Seja $M$ uma máquina de Turing.
    A \emph{função computada por $M$}
    é a função parcial $f: \{0, 1\}^* \to \{0, 1\}^*$
    tal que $f(x)$ está definida se e somente se $M(x)$ existe,
    e, nestes casos, $f(x) = M(x)$.

    Uma função $f$ é \emph{recursiva parcial}
    se for computada por alguma máquina $M$.
    Se $f$ estiver definida para todo $x \in \{0, 1\}^*$,
    dizemos que $f$ é \emph{recursiva total}.
\end{definition}
(Esta definição é uma variação da definição de \citeonline[p.~151]{HopcroftUllman1979};
em particular, utilizaremos funções que mapeiam palavras para palavras
em vez de funções que mapeiam números naturais para números naturais.)

\subsubsection{Codificação de objetos}

Conforme observado por \citeonline[p.~2]{AroraBarak2009},
não perdemos generalidade restringir funções a palavras de $\{0, 1\}^*$,
pois podemos codificar objetos matemáticos complexos usando o sistema binário
--- de fato,
é exatamente isso o que fazemos nos computadores modernos.
Podemos, por exemplo,
codificar inteiros usando sua representação binária,
e grafos podem ser representados por sua matriz de adjacência
ou pelos pares de nodos adjacentes.
\citeonline[p.~10]{GareyJohnson1979} argumentam que
não é necessário se ater aos detalhes da representação dos objetos,
pois quaisquer duas codificações ``razoáveis'' destes objetos
irão diferir polinomialmente de tamanho.

Neste trabalho,
dois objetos aparecerão mais frequentemente:
máquinas de Turing e tuplas.
Uma máquina de Turing pode ser representada em binário
listando todos elementos da função de transição
\cite[p.~182]{HopcroftUllman1979};
os detalhes estão no apêndice~\ref{app:turing_machines}.
Denotaremos por $\langle M \rangle$ a representação em binário da máquina $M$.

Já uma tupla $(x_1, x_2, \dots, x_n)$ pode ser codificada
combinando as representações em binário de $x_1, \dots, x_n$.
A ideia é trocar, nas representações em binário,
$0$ por $00$ e $1$ por $01$;
então, a cadeia $1$ faz o papel de separador.
Denotaremos por $\langle x_1, x_2, \dots, x_n \rangle$
a representação binária da tupla $(x_1, x_2, \dots, x_n)$.
Observe que esta codificação é não"=ambígua;
podemos recuperar a representação em binário de cada um dos $x_i$
a partir de $\langle x_1, \dots, x_n \rangle$.

(Em geral, $\langle x \rangle$ denotará a representação em binário
do objeto matemático $x$.
\citeonline[p.~2]{AroraBarak2009} usa $\llcorner x \rlcorner$
para o mesmo fim;
eu escolhi a notação $\langle x \rangle$
por conformidade com a notação de \citeonline[p.~182]{HopcroftUllman1979}.)

\subsection{Enumeração de máquinas de Turing}
\subsection{Teorema da Máquina Universal}
\subsection{Teorema $s-m-n$}
\subsection{Enumerações de Gödel aceitáveis}
