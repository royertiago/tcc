\subsection{Principais Classes de Complexidade Computacional}
\label{sec:standard_classes}

\begin{definition}
    \begin{align*}
        \P &= \bigcup_{k \geq 1} \DTIME(n^k) \\
        \NP &= \bigcup_{k \geq 1} \NTIME(n^k) \\
        \PSPACE &= \bigcup_{k \geq 1} \DSPACE(n^k) \\
        \NPSPACE &= \bigcup_{k \geq 1} \NSPACE(n^k) \\
    \end{align*}
\end{definition}

De acordo com o teorema da união,
estes conjuntos são classes de complexidade.

As classes $\P$ e $\NP$ são as protagonistas
do problema mais importante da Ciência da Computação teórica.
De um lado, temos a classe $\P$,
as linguagens que podem ser resolvidas em tempo polinomial.
De outro, temos a classe $\NP$,
as linguagens que podem ser verificadas em tempo polinomial.%
\footnote{
    \label{foot:polinomially_balanced}
    A ideia é que,
    se dispomos de uma sequência de transições para uma máquina não"=determinística,
    podemos rapidamente executar esta sequência de transições
    e verificar que a entrada, de fato, pertence à linguagem;
    isto é, depois que o problema está resolvido,
    é fácil verificar se a solução está correta ou não.

    Existe uma caracterização alternativa da classe $\NP$ baseada nesta ideia.
    Uma linguagem $L$ \emph{polinomialmente equilibrada}
    é um conjunto de pares $(x, y)$ de palavras
    tais que $|y| \leq p(|x|)$ para algum polinômio $p$
    \cite[p.~298]{Papadimitriou1998}
    --- isto é, $y$ não é muito maior do que $x$.

    Se uma linguagem $L$ está em $\NP$,
    podemos construir uma linguagem $L' \in \P$,
    polinomialmente equilibrada,
    tal que o conjunto $\{x \mid (x, y) \in L \text{ para algum $y$ }\}$
    é exatamente o conjunto $L$.
    É como se $x$ fosse um problema a ser solucionado
    e $y$ fosse a sua solução.

    O contrário também vale: a partir de $L' \in \P$,
    podemos construir $L \in \NP$.
    Portanto, podemos interpretar o problema $\P$ vs $\NP$
    como a diferença entre resolver um problema pela primeira vez
    e verificar que uma solução já pronta funciona.
}

De acordo com o teorema de Savitch,
\begin{equation*}
    \NSPACE(n^k) \subseteq \DSPACE(n^{2k}),
\end{equation*}
portanto temos
\begin{equation*}
    \NPSPACE = \PSPACE.
\end{equation*}
Este resultado é surpreendente:
enquanto que, para a complexidade de tempo,
o uso de não"=determinismo aparenta fornecer ganhos exponenciais,
para a complexidade de espaço,
o ganho é meramente quadrático.

Pelas equações \ref{eq:dtime_in_ntime} e~\ref{eq:ntime_in_dspace},
sabemos que a seguinte cadeia de inclusões é verdadeira:
\begin{equation*}
    \P \subseteq \NP \subseteq \PSPACE \quad (= \NPSPACE).
\end{equation*}

Embora os cientistas da computação em geral acreditem
que ambas as inclusões sejam estritas \cite[p.~54]{Gasarch2012},
nós sequer tivemos sucesso em demonstrar que
\begin{equation*}
    \P \subsetneq \PSPACE.
\end{equation*}
