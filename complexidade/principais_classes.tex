\subsection{Principais Classes de Complexidade Computacional}
\label{classes_complexidade}

\begin{definition}
    \begin{align*}
        \P &= \bigcup_{n \geq 1} \DTIME(n^k) \\
        \NP &= \bigcup_{n \geq 1} \NTIME(n^k) \\
        \PSPACE &= \bigcup_{n \geq 1} \DSPACE(n^k) \\
        \NPSPACE &= \bigcup_{n \geq 1} \NSPACE(n^k) \\
    \end{align*}
\end{definition}

De acordo com o teorema da união,
estes conjuntos são classes de complexidade.

As classes $\P$ e $\NP$ são as protagonistas
do problema mais importante da Ciência da Computação teórica.
De um lado, temos a classe $\P$,
as linguagens que podem ser resolvidas em tempo polinomial.
De outro, tempos a classe $\NP$,
as linguagens que podem ser verificadas em tempo polinomial%
\footnote{
    A ideia é que,
    se dispomos de uma sequência de transições para uma máquina não-determinística,
    podemos rapidamente executar esta sequência de transições
    e verificar que a entrada, de fato, pertence à linguagem;
    isto é, depois que o problema está resolvido,
    é fácil verificar se a solução está correta ou não.

    Existe uma caracterização alternativa da classe $\NP$ baseada nesta ideia.
    Uma $L$ linguagem \emph{polinomialmente balanceada}
    é um conjunto de pares $(x, y)$ de palavras
    tal que $|y| \leq p(|x|)$ para algum polinômio $p$
    \cite[p. 298]{Papadimitriou1998}
    --- isto é, $y$ não é muito maior do que $x$.

    Se uma linguagem $L$ está em $\NP$,
    podemos construir uma linguagem $L' \in \P$,
    polinomialmente balanceada,
    tal que o conjunto $\{x \mid (x, y) \in L \text{ para algum $y$ }\}$
    é exatamente o conjunto $L$.
    É como se $x$ fosse um problema a ser solucionado
    e $y$ fosse a sua solução.

    O contrário também vale: a partir de $L' \in \P$,
    podemos construir $L \in \NP$.
    Portanto, podemos interpretar o problema $\P$ vs $\NP$
    como o contraposição entre resolver um problema pela primeira vez
    e verificar que uma solução já pronta funciona.

    Não utilizaremos a noção de linguagem polinomialmente equilibrada neste texto.
}.
Sabemos que $\P \subseteq \NP$;
a inclusão contrária é um problema em aberto
--- apesar dos esforços de cientistas da computação mundo afora,
ainda não sabemos se estas duas classes são iguais ou não.

Pela equação \ref{ntime_in_dspace},
sabemos que a seguinte cadeia de inclusões é verdadeira:
\begin{equation*}
    \P \subseteq \NP \subseteq \PSPACE \subseteq \NPSPACE.
\end{equation*}
O teorema de Savitch nos diz que as duas últimas classes são iguais.
Mas nós sequer sabemos se $\P$ é igual a $\PSPACE$ ou não.
