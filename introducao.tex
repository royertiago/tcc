\chapter{INTRODUÇÃO}

A teoria da computabilidade
classifica os problemas computacionais entre
aqueles que podem e não podem ser resolvidos mecanicamente.
Existem diversos dispositivos matemáticos
que tentam capturar esta noção de
``resolvidos mecanicamente'';
o modelo que usaremos neste trabalho é a máquina de Turing.

Dizemos que um problema é \emph{decidível}
se ele puder ser resolvido por uma máquina de Turing.
Embora as máquinas de Turing
não se pareçam com os computadores modernos,
estes dois dispositivos são equivalentes,
no sentido de que
todos os problemas resolvíveis por um deles
também é resolvível pelo outro.
\footnote{
    Eles são equivalentes até certo ponto.
    Máquinas de Turing são objetos matemáticos
    com ``memória infinita'',
    enquanto que os computadores estão limitados
    à uma quantidade finita de memória.
}
Portanto, podemos pensar nos problemas decidíveis
como aqueles que podem ser resolvidos com o uso de um computador
\cite[p. 307]{HopcroftMotwaniUllman2001}.
Embora a maior parte dos problemas
encontrados no dia-a-dia seja decidível,
existem alguns problemas de importância teórica e prática
que não o são.
% TODO: Adicionar citação aqui.
Um exemplo notável é determinar se dois programas são equivalentes.
\footnote{
    Este problema possui importância prática:
    caso existisse um algoritmo para determinar equivalência entre programas,
    poderíamos usar um computador para saber se
    determinado refatoramento ou otimização de código
    não alterou acidentalmente o significado do programa;
    isto é, a mudança não introduziu um bug.
}

Entretanto,
apenas ser decidível não é suficiente.
Existem alguns problemas
(de fato, categorias inteira deles)
que, por mais rápido que seja o computador
que esteja tentando resolvê-lo,
o tempo necessário torna-se excessivamente grande
muito rapidamente.
Chamamos estes problemas de \emph{intratáveis}
\cite[p. 1]{HopcroftMotwaniUllman2001}
Por mais que eles sejam decidíveis,
pode ser que demore até o Sol esfriar
(evento que estima-se que vá ocorrer em 5 bilhões de anos)
para que o computador devolva a solução.

É aqui que entra a teoria de complexidade computacional.
Essencialmente,
\emph{complexidade}
é a quantidade de recursos que são gastos
para obter a solução de determinado problema.
Geralmente nos concentramos em um único recurso;
pode ser o tempo de execução,
quantidade de memória RAM usada,
ou,
para a complexidade de circuitos,
o tamanho do circuito
(quantidade de portas lógicas usadas na sua construção)
ou sua profundidade
(maior número de portas lógicas entre uma entrada e uma saída).

O mais famoso problema da área de complexidade computacional
é o $P$ versus $NP$.
Os problemas da classe $P$
são os que podem ser resolvidos em tempo polinomial
por uma Máquina de Turing determinística,
enquanto que a classe $NP$
contempla os problemas que podem ser resolvidos em tempo polinomial
por Máquinas não-determinísticas.
Os problemas considerados são problemas de decisão;
isto é,
determinar se uma palavra está ou não
numa determinada linguagem.
$P$ e $NP$ são conjuntos de linguagens
que correspondem a problemas de decisão.
Sabemos que $P \subseteq NP$;
o problema $P$ versus $NP$
pergunta se esta inclusão é estrita ou não \cite{Sipser2006}.
A maior parte dos pesquisadores acredita que $P \neq NP$
\cite[p. 2]{Gasarch2012},
embora ainda não tenhamos demonstrado nada.

Uma das ``frentes de ataque''
consiste em tentar ``enfraquecer''
a máquina de Turing.
A ideia é trabalhar com um modelo de computação muito mais restritivo,
provar um equivalente a $P \neq NP$
para este modelo de computação,
e transpôr esta demonstração para o modelo de Turing.
Circuitos booleanos
são exemplos de modelos de computação mais simples.
Como eles não têm ``partes móveis''
ou múltiplos estados,
intuitivamente uma demonstração de que $P \neq NP$
deve ser mais simples de se obter
neste dispositivo computacional. \cite{Hastad1987}.

As duas principais medidas
de complexidade de circuitos
são a quantidade de portas lógicas
e a profundidade do circuito.
Existem várias classes de complexidades de circuitos
que exploram estas duas métricas;
neste trabalho,
pretende-se relacionar estas classes de complexidade
com as classes de complexidade computacional.

\section{Objetivos}

Estabelecer relações entre classes de complexidade computacional
e complexidade de circuitos.

\subsection{Objetivos Especificos}

\begin{enumerate}
    \item Estudar as classes de complexidade computacional
        e complexidade de circuitos.
    \item Demonstrar a relação entre complexidade de circuitos
        e o problema $P$ versus $NP$.
    \item Correlacionar as principais classes
        de complexidade computacional
        às correspondentes classes de complexidade de circuitos
    \item Estabelecer limites inferiores no tamanho
        e profundidade dos circuitos
        que computam certas funções recursivas.
\end{enumerate}
