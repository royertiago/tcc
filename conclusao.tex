\chapter{COMPARAÇÃO COM OUTROS TRABALHOS}

Este capítulo discute brevemente outros trabalhos que,
de certa forma,
tentam capturar a noção de ``função não"=determinística''.

\section{PROBLEMAS DE BUSCA VS PROBLEMAS DE DECISÃO (PAPADIMITRIOU)}
\label{sec:papadimitriou_comparison}

\citeonline[p.~229]{Papadimitriou1994}
define $\FNP$ diferente de nossa definição
(na seção~\ref{sec:functional_complexity}).

\begin{definition}
    Uma linguagem $L$ é \emph{polinomialmente equilibrada}
    se existir algum polinômio $p$ tal que
    todos os elementos de $L$ são pares ordenados da forma $(x, y)$
    em que $|y| \leq p(|x|)$.
\end{definition}
Isto é, $L$ é constituída de pares,
de forma que o segundo elemento do par não é muito maior que o primeiro elemento.

Linguagens de $\NP$ e linguagens polinomialmente equilibradas
estão relacionadas por certificados de pertinência.
Por exemplo,
para a linguagem $\SAT$,
podemos provar eficientemente
(isto é, em tempo polinomial)
que determinada instância $\varphi$ é satisfazível
se fornecermos uma atribuição de valores"=verdade que satisfaz a instância;
esta atribuição é uma \emph{testemunha} ou \emph{certificado}
para a pertinência de $\varphi$ a $\SAT$.

Para cada linguagem $L \in \NP$,
podemos sistematicamente prover certificados de pertinência para $L$:
como sabemos que existe uma máquina de Turing não"=determinística que decide $L$,
podemos fornecer a sequência de transições não"=determinísticas
como um certificado de pertinência.
Como esta máquina opera em tempo polinomial,
para cada $x \in L$,
o par
\begin{equation*}
    (x, y),
\end{equation*}
em que $y$ é esta sequência de transições,
satisfará $|y| \leq p(|x|)$,
para algum polinômio $p$
--- no caso, $p$ é o próprio limite de tempo da máquina não"=determinística
que reconhece $L$.

Dessa forma,
podemos, sistematicamente,
associar uma linguagem $L \in \NP$
a uma linguagem polinomialmente equilibrada $R_L \in \P$.
Assim,
construiremos o conjunto $\FNP$ definido por \citeonline[p.~229]{Papadimitriou1994}.

\begin{definition}
    Se $L \in \NP$, chame de $R_L$
    uma linguagem polinomialmente equilibrada associada com $L$.
    Então defina $\FNP$ por
    \begin{equation*}
        \FNP = \{R_L \mid L \in \NP\}
    \end{equation*}
    \cite[p.~229]{Papadimitriou1994}
\end{definition}

Estes problemas são por vezes chamados de \emph{problemas de busca}
(do inglês \emph{search problem}),
em oposição a \emph{problemas de decisão}.

Do ponto de vista computacional,
a definição de Papadimitriou captura a ideia de
encontrar alguma solução para o problema $L$,
potencialmente descartando uma quantidade exponencial de outras soluções.

Esta definição contorna o problema de definir ``função não"=determinística''
trabalhando diretamente com os certificados de pertinência.
Entretanto,
a ausência do conceito de função
dificulta a formalização do conceito de oráculo
(pois não há mais uma única resposta ``certa'',
mas sim várias)
e impossibilita a análise do efeito da composição de funções,
como a feita na seção~\ref{sec:function_composition}.

\section{CONJUNTO POTÊNCIA COMO CONTRADOMÍNIO (ANDREEV)}

\citeonline[p.~3]{Andreev1994}
apresenta uma abordagem diferente.
Em vez de tentar amarrar algum dos ramos de computação,
a função retornará todos eles.

\begin{definition}
    Sejam $\mathcal A$ e $\mathcal B$ conjuntos finitos,
    e $2^\mathcal B$ o conjunto potência de $\mathcal B$.
    Uma \emph{função não"=determinística de $\mathcal A$ em $\mathcal B$}
    é uma função da forma
    \begin{equation*}
        f : \mathcal A \to 2^\mathcal B.
    \end{equation*}
    \cite[p.~3]{Andreev1994}
\end{definition}

Os conjuntos $\mathcal A$ e $\mathcal B$ usados por \citeonline[p.~4]{Andreev1994}
são da forma $\{0, 1\}^k$.
A ideia é que $\mathcal A$ represente as possíveis entradas para um circuito booleano,
e que $\mathcal B$ represente as saídas desse circuito.
Dado um circuito computacional $S$,
com $k$ entradas e $l$ saídas,
dizemos que $S$ computa a função não"=determinística $F$ de $\{0, 1\}^k$ em $\{0, 1\}^l$
se,
para todo $a \in \{0, 1\}^k$,
$S(a) \in F(a)$.
Isto é,
todas as saídas possíveis de $S$ estão previstas em $F$.
Esta definição é similar à definição de \citeonline[p.~229]{Papadimitriou1994},
no sentido de que basta retornar um valor de $F(a)$.
\citeonline[p.~4]{Andreev1994}
define, então,
a \emph{complexidade} de uma função não"=determinística $F$
como sendo o tamanho do menor circuito que computa $F$.

O fato de Andreev se restringir a domínio e contradomínio finitos
mostra que esta definição não ``combina'' corretamente
a noção de função determinística com máquinas não"=determinísticas,
pois as funções operam sobre o domínio $\{0, 1\}^*$.

Além disso,
como o domínio e o contradomínio das funções não"=determinísticas de Andreev
são diferentes,
seria necessário um malabarismo adicional
para desenvolver a noção de composição de funções,
assim como na definição de Papadimitriou.

\section{DEFINIÇÃO DE HOPCROFT E ULLMAN}

A definição de \citeonline[p.~313]{HopcroftUllman1979},
mencionada na introdução,
é a que motivou este trabalho.
\begin{definition}
    Seja $M$ uma máquina de Turing não"=determinística.
    Dizemos que $M(x) = y$ se
    algum dos ramos de computação de $M$ em $x$ produz $y$,
    e nenhum outro ramo de computação que se encerre
    produz um valor diferente de $y$.
    \cite[p.~313]{HopcroftUllman1979}
\end{definition}

O problema é que esta definição não enumera corretamente as funções recursivas.
O grande vilão está na permissão que damos à máquina $M$
não parar em todos os ramos de computação.

Por exemplo,
construa uma máquina $N$ que,
na entrada $\langle M, x \rangle$,
assuma dois ramos de computação:
no primeiro,
$N$ incondicionalmente escreve $1$ na fita de saída e para.
No outro, $N$ simula a máquina determinística $M$ em $x$ e,
caso $M$ pare ao computar $x$,
$N$ escreve $0$ na fita.

Se $M$ não para em $x$,
então $N$ possui um único ramo de computação que para,
e este ramo produz $1$ na fita;
portanto, $N(\langle M, x \rangle) = 1$.
Caso $M$ pare ao computar $x$,
$N(\langle M, x \rangle)$ estará indefinido,
pois dois ramos de computação de $N$ escrevem coisas diferentes na fita.

Ou seja,
esta máquina computa
\begin{equation*}
    f(\langle M, x \rangle) = 1, \text{ se $M$ não parar ao computar $x$,}
\end{equation*}
que é exatamente o complemento do problema da parada.
Portanto,
pela definição de Hopcroft e Ullman,
conseguimos enumerar funções não"=recursivas.

Mas,
se impormos à definição de Hopcroft e Ullman a restrição adicional
de que todos os ramos de $M$ devem parar para que $M(x)$ exista,
então não há a necessidade de haver vários ramos de computação,
pois todos eles retornam o mesmo resultado.
Basta fixar uma das possíveis transições não"=determinísticas,
tornando a máquina \emph{determinística}.
Neste caso,
perdemos o aparente ganho de tempo exponencial ao usar não"=determinismo.

\section{PROBLEMAS DE OTIMIZAÇÃO (KRENTEL)}

Dentre os trabalhos avaliados,
o artigo de \citeonline[p.~493]{Krentel1988}
é o que mais se aproxima do trabalho desenvolvido neste TCC.

Krentel define a classe $\OptP$,
\simbolo{$\OptP$}{Classe polinomial de problemas de otimização}
os problemas de otimização que rodam em tempo polinomial,
como sendo,
na terminologia da seção~\ref{sec:functional_complexity},
\begin{equation*}
    \OptP = \FNP \cup \coFNP.
\end{equation*}

Entretanto,
a principal diferença é na forma como é definida completude.
\begin{definition}
    Uma função $f \in \OptP$ é completa para $\OptP$
    se, para toda função $g \in \OptP$,
    existir um par de funções $T_1, T_2 \in \P$
    tais que
    \begin{equation*}
        g(x) = T_2( x, f(T_1(x)) ).
    \end{equation*}
\end{definition}

Nossa definição de $\FNP$"=completo
buscava generalizar diretamente a noção de $\NP$"=completude.
Conforme observado na demonstração do teorema~\ref{thm:pi_f_subseteq_delta_f},
podemos, em tempo polinomial determinístico,
inverter a ordenação das palavras, se elas tiverem um tamanho fixo.
Portanto,
usando este pós"=processamento,
podemos tornar uma função que maximiza seus ``valores não"=determinísticos''
(isto é, sua árvore de computação não"=determinística)
numa função que os minimiza.
Como Krentel já embutiu os problemas de maximização e minimização em $\OptP$,
não há problema em permitir o pós"=processamento feito por $T_2$.

Entretanto,
graças a $T_2$,
a classe $\OptP$ acaba ``funcionando'' como nossa classe $\Delta_n^f$,
pois,
como observado no teorema~\ref{thm:strong_compositive_closure},
podemos resolver todos os problemas de $\Delta_n^f$
apenas pós"=processando um resultado de $\FNP$.
Portanto não é possível construir uma ``hierarquia polinomial funcional''
com base em $\OptP$.

\section{CONSIDERAÇÕES FINAIS}

Neste trabalho,
desenvolvemos uma teoria de funções não"=determinísticas,
guiados pelo objetivo de poder definir sua complexidade
em termos dos axiomas de Blum.
Conseguimos generalizar a classe $\NP$ para problemas funcionais
(a classe $\FNP$)
da mesma forma como a classe $\FP$ generaliza a classe $\P$;
problemas de $\NP$,
como $\SAT$,
possuem uma generalização natural em nossa classe $\FNP$,
como encontrar uma atribuição satisfazível, no caso de $\SAT$.

O objetivo de manter compatibilidade com os axiomas de Blum foi atingido.
É interessante notar que, dos trabalhos analisados neste capítulo,
apenas Hopcroft se preocupa com os axiomas de Blum.
Além disso,
nenhum dos autores tenta interpretar as funções não"=determinísticas
como uma enumeração de Gödel,
que é um passo necessário para que uma medida de complexidade
satisfaça aos axiomas de Blum.

Também pudemos construir uma ``hierarquia polinomial funcional'',
simplesmente adaptando as definições da hierarquia polinomial ``tradicional''.
O fato de estarmos trabalhando com funções
cujo domínio e contradomínio coincidem
nos permitiu compô"=las,
possibilitando resultados como o teorema~\ref{thm:compositive_closure},
que nos deu uma interpretação de $\Delta_n^f$
em termos da composição de funções de $\Sigma_n^f$.

Dentre os trabalhos analisados,
o único que contém definições parecidas com o que foi desenvolvido neste TCC
é o de \cite[p.~3]{Krentel1988},
que foi encontrado apenas no final do desenvolvimento.
Com isso,
as referências bibliográficas acabaram todas ``presas''
no século passado.
Seria interessante refazer a pesquisa bibliográfica,
mas direcionando para trabalhos que lidem com problemas de otimização
(como a classe OptP, de Krentel).

Os dois principais problemas que ficaram em aberto
estão relacionados à hierarquia polinomial funcional desenvolvida.
A demonstração do teorema~\ref{thm:compositive_closure}
utilizou o problema completo
\begin{equation*}
    \HaltFNP^{\FNP^\mathcal A},
\end{equation*}
retirado do teorema~\ref{thm:polinomially_complete_problems}.
A formulação deste problema é baseada no problema da parada.
Como observado por \citeonline[p.~255]{Papadimitriou1994},
esse tipo de classe de complexidade\footnote{
    As \emph{classes de complexidade sintáticas}
    são aquelas em que a pertinência à classe
    depende apenas do modelo de máquina utilizado
    \cite[p.~255]{Papadimitriou1994}.
    (Note que esta não é uma definição formal.)
    Por exemplo,
    classes como $\P$, $\NP$, $\FNP$ etc.\ são classes de complexidade sintáticas;
    enquanto que a classe dos problemas $\NP$"=completos não é
    --- esta é uma classe \emph{semântica}.
}
sempre possuirá um problema completo da forma como é $\HaltFNP$.
Fica em aberto determinar se existem problemas mais naturais
que sejam completos para os demais níveis da hierarquia polinomial funcional.

Outro problema é o mencionado no final do capítulo~\ref{ch:nondeterministic_functions},
que é a possibilidade de termos ``exagerado na dose''
ao definir o valor de $M(x)$ como sendo o máximo dos ramos de computação.
Dessa forma,
com um simples pós"=processamento
(conforme o teorema~\ref{thm:strong_compositive_closure}),
podemos simular várias chamadas a um mesmo oráculo.
Seria interessante tentar ``enfraquecer'' esta definição,
não permitindo mais que uma única chamada
dê informação equivalente a várias,
criando uma hierarquia mais densa de problemas.
