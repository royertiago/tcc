\chapter{Comparação com outros trabalhos}

Este capítulo discute brevemente outros trabalhos que,
de certa forma,
tentam capturar a noção de ``função não"=determinística''.

\section{Problemas de busca vs problemas de decisão (Papadimitriou)}
\label{sec:papadimitriou_comparison}

\citeonline[p.~229]{Papadimitriou1994}
define $\FNP$ diferente de nossa definição
(na seção~\ref{sec:functional_complexity}).

\begin{definition}
    Uma linguagem $L$ é \emph{polinomialmente equilibrada}
    se existir algum polinômio $p$ tal que
    todos os elementos de $L$ são pares ordenados da forma $(x, y)$
    em que $|y| \leq p(|x|)$.
\end{definition}
Isto é, $L$ é constituída de pares,
de forma que o segundo elemento do par não é muito maior que o primeiro elemento.

Linguagens de $\NP$ e linguagens polinomialmente equilibradas
estão relacionadas por certificados de pertinência.
Por exemplo,
para a linguagem $\SAT$,
podemos provar eficientemente
(isto é, em tempo polinomial)
que determinada instância $\varphi$ é satisfazível
se fornecermos uma atribuição de valores"=verdade que satisfaz a instância;
esta atribuição é uma \emph{testemunha} ou \emph{certificado}
para a pertinência de $\varphi$ a $\SAT$.

Para cada linguagem $L \in \NP$,
podemos sistematicamente prover certificados de pertinência para $L$:
como sabemos que existe uma máquina de Turing não"=determinística que decide $L$,
podemos fornecer a sequência de transições não"=determinísticas
como um certificado de pertinência.
Como esta máquina opera em tempo polinomial,
para cada $x \in L$,
o par
\begin{equation*}
    (x, y),
\end{equation*}
em que $y$ é esta sequência de transições,
satisfará $|y| \leq p(|x|)$,
para algum polinômio $p$
--- no caso, $p$ é o próprio limite de tempo da máquina não"=determinística
que reconhece $L$.

Dessa forma,
podemos, sistematicamente,
associar uma linguagem $L \in \NP$
a uma linguagem polinomialmente equilibrada $R_L \in \P$.
Assim,
construiremos o conjunto $\FNP$ definido por \citeonline[p.~229]{Papadimitriou1994}.

\begin{definition}
    Se $L \in \NP$, chame de $R_L$
    uma linguagem polinomialmente equilibrada associada com $L$.
    Então defina $\FNP$ por
    \begin{equation*}
        \FNP = \{R_L \mid L \in \NP\}
    \end{equation*}
    \cite[p.~229]{Papadimitriou1994}
\end{definition}

Estes problemas são por vezes chamados de \emph{problemas de busca}
(do inglês \emph{search problem}),
em oposição a \emph{problemas de decisão}.

Do ponto de vista computacional,
a definição de Papadimitriou captura a ideia de
encontrar alguma solução para o problema $L$,
potencialmente descartando uma quantidade exponencial de outras soluções.

Esta definição contorna o problema de definir ``função não"=determinística''
trabalhando diretamente com os certificados de pertinência.
Entretanto,
a ausência do conceito de função
dificulta a formalização do conceito de oráculo
(pois não há mais uma única resposta ``certa'',
mas sim várias)
e impossibilita a análise do efeito da composição de funções,
como a feita na seção~\ref{sec:function_composition}.

\section{Conjunto potência como contradomínio (Andreev)}

\citeonline[p.~3]{Andreev1994}
apresenta uma abordagem diferente.
Em vez de tentar amarrar algum dos ramos de computação,
a função retornará todos eles.

\begin{definition}
    Sejam $\mathcal A$ e $\mathcal B$ conjuntos finitos,
    e $2^\mathcal B$ o conjunto potência de $\mathcal B$.
    Uma \emph{função não"=determinística de $\mathcal A$ em $\mathcal B$}
    é uma função da forma
    \begin{equation*}
        f : \mathcal A \to 2^\mathcal B.
    \end{equation*}
    \cite[p.~3]{Andreev1994}
\end{definition}

Os conjuntos $\mathcal A$ e $\mathcal B$ usados por \citeonline[p.~4]{Andreev1994}
são da forma $\{0, 1\}^k$.
A ideia é que $\mathcal A$ represente as possíveis entradas para um circuito booleano,
e que $\mathcal B$ represente as saídas desse circuito.
Dado um circuito computacional $S$,
com $k$ entradas e $l$ saídas,
dizemos que $S$ computa a função não"=determinística $F$ de $\{0, 1\}^k$ em $\{0, 1\}^l$
se,
para todo $a \in \{0, 1\}^k$,
$S(a) \in F(a)$.
Isto é,
todas as saídas possíveis de $S$ estão previstas em $F$.
Esta definição é similar à definição de \citeonline[p.~229]{Papadimitriou1994},
no sentido de que basta retornar um valor de $F(a)$.
\citeonline[p.~4]{Andreev1994}
define, então,
a \emph{complexidade} de uma função não"=determinística $F$
como sendo o tamanho do menor circuito que computa $F$.

O fato de Andreev se restringir a domínio e contradomínio finitos
mostra que esta definição não ``combina'' corretamente
a noção de função determinística com máquinas não"=determinísticas,
pois as funções operam sobre o domínio $\{0, 1\}^*$.

Além disso,
como o domínio e o contradomínio das funções não"=determinísticas de Andreev
são diferentes,
seria necessário um malabarismo adicional
para desenvolver a noção de composição de funções,
assim como na definição de Papadimitriou.

\section{Definição de Hopcroft e Ullman}

A definição de \citeonline[p.~313]{HopcroftUllman1979},
mencionada na introdução,
é a que motivou este trabalho.
\begin{definition}
    Seja $M$ uma máquina de Turing não"=determinística.
    Dizemos que $M(x) = y$ se
    algum dos ramos de computação de $M$ em $x$ produz $y$,
    e nenhum outro ramo de computação que se encerre
    produz um valor diferente de $y$.
    \cite[p.~313]{HopcroftUllman1979}
\end{definition}

O problema é que esta definição não enumera corretamente as funções recursivas.
O grande vilão está na permissão que damos à máquina $M$
não parar em todos os ramos de computação.

Por exemplo,
construa uma máquina $N$ que,
na entrada $\langle M, x \rangle$,
assuma dois ramos de computação:
no primeiro,
$N$ incondicionalmente escreve $1$ na fita de saída e para.
No outro, $N$ simula a máquina determinística $M$ em $x$ e,
caso $M$ pare ao computar $x$,
$N$ escreve $0$ na fita.

Se $M$ não para em $x$,
então $N$ possui um único ramo de computação que para,
e este ramo produz $1$ na fita;
portanto, $N(\langle M, x \rangle) = 1$.
Caso $M$ pare ao computar $x$,
$N(\langle M, x \rangle)$ estará indefinido,
pois dois ramos de computação de $N$ escrevem coisas diferentes na fita.

Ou seja,
esta máquina computa
\begin{equation*}
    f(\langle M, x \rangle) = 1, \text{ se $M$ não parar ao computar $x$,}
\end{equation*}
que é exatamente o complemento do problema da parada.
Portanto,
pela definição de Hopcroft e Ullman,
conseguimos enumerar funções não"=recursivas.

Mas,
se impormos à definição de Hopcroft e Ullman a restrição adicional
de que todos os ramos de $M$ devem parar para que $M(x)$ exista,
então não há a necessidade de haver vários ramos de computação,
pois todos eles retornam o mesmo resultado.
Basta fixar uma das possíveis transições não"=determinísticas,
tornando a máquina \emph{determinística}.
Neste caso,
perdemos o aparente ganho de tempo exponencial ao usar não"=determinismo.
