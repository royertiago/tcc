\documentclass[12pt]{article}
\usepackage{sbc/template}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{amsthm}
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}[definition]{Example}

\usepackage{complexity}

\sloppy

\title{Blum axioms and nondeterministic computation of functions}

\author{Tiago Royer\inst{1}}

\address{
    Departamento de Informática e Estatística
    --- Universidade Federal de Santa Catarina
    \email{royertiago@gmail.com}
}

\begin{document}

\maketitle

\begin{abstract}
    In his doctoral thesis,
    Manuel Blum proposed two axioms for complexity measures
    that allows us to talk about complexity in an axiomatic manner.
    His axioms does not even specify the machine model
    --- it just requires it to satisfy some properties.
    Blum axioms, however,
    are defined in the context of function computation.
    This restriction is easy to implement with deterministic machines,
    since there is only one output for a given input,
    but how can a nondeterministic Turing machine compute a function?
    This paper surveys techniques to associate
    nondeterministic machines with functions
    and analyze how they interact with computational complexity.
\end{abstract}

\section{Introduction}

\section{Gödel numberings}

% TODO: Note that this is a simplification

Gödel's famous Incompleteness Theorem says that
any correct and consistent formal system that includes the Peano arithmetic
will have statements that are true under that system,
but \emph{cannot be proven} under that system.
In essence,
in the proof of this theorem,
Gödel created self-referential proposition $\varphi$
that essentially says ``$\varphi$ is not provable''.
Then, if $\varphi$ is false,
by it's own assertion, it must be provable;
but, as the system is consistent,
this would mean that $\varphi$ is true
--- a contradiction.
Hence, $\varphi$ must be true.
But, as it is true,
there cannot be a proof under the current formal system to it
--- that is exactly what $\varphi$ asserts.
So,
we get a proposition we know it is true,
but we cannot prove it using only tools of that system.

We can have a glimpse at how Gödel managed to construct a formula like $\varphi$
by analyzing how Turing constructed a language
that cannot be decided by Turing machines.

The language built by Turing is known today as the halting problem.
In essence,
you are given a Turing machine $M$ and an input $w$
and must decide whether $M$ eventually halts when processing $w$.
To prove that this problem is undecidable,
Turing had first to somehow encode this problem as a language
(because all a Turing machine can understand are sentences of a language);
the key point is that the Turing machine formalism
had to be encoded into words that could be fed to Turing machines.
Thus we could pick any machine and feed its own description as an input;
this form of self-reference is analogous
to Gödel's unprovable but true sentence.

In our context,
a \emph{Gödel numbering} will simply be a means
of associating every word $w$ of $\{0, 1\}^*$
with a computable function.
Section~\ref{sec:acceptable-godel-numberings} shows a refinement of this notion,
and section~\ref{sec:blum-axioms}
defines the Blum axioms over the refined definition.

\subsection{Acceptable Gödel numberings}
\label{sec:acceptable-godel-numberings}

\begin{definition}
    Let $\mathcal P$ be the the set of partial computable functions.
    A \emph{Gödel numbering}
    is a function $\phi: \{0, 1\}^* \to \mathcal P$
    that is surjective.
\end{definition}

A Gödel numbering formalizes the concept of associating a word $w$ of $\{0, 1\}^*$
with a partial recursive function $f$ of $\mathcal P$.
We can think of $w$ as being the ``source code'' for the ``program'' $f$;
we denote $f = \phi(w)$ by $\phi_w$.

Because Gödel numberings are infinite mathematical objects,
Turing machines cannot manipulate them directly.
We thus need some technique to manipulate the numbering indirectly.

Call $\pi$ the standard Gödel numbering
that corresponds to the standard representation of Turing machines;
that is, if $w$ is the encoding of a Turing machine $M$,
then $\pi_w$ is the partial function computed by $M$.
We can manipulate $\pi$ indirectly, for instance,
by means of a universal Turing machine $U$.
Given a program $w$ and an input $x$,
if $\pi_w(x)$ exists,
then the output of the machine $U$ when its input is the pair $(w, x)$
is exactly $\pi_w(x)$.
Therefore,
even tough we did not directly manipulate the numbering $\pi$
or calculate $\pi_w$,
we did manage to indirectly compute the value of $\pi_w(x)$.
This is the \emph{universal machine theorem}.

We can also manipulate the source code directly.
Suppose $w$ represents a Turing machine that computes a function of two variables $f$.
Given two inputs $x$ and $y$, we can compute $f(x, y) = \pi_w(x, y)$
using the universal Turing machine.
If we are given a single input $x$ and leave the second variable free,
we have a function $g$ of one variable, such that
\begin{equation*}
    g(y) = f(x, y).
\end{equation*}
That is, we fixed the first input to be $x$.

This function $g$ is computable;
in fact, we can obtain a source code $w'$ for $g$ from $w$
--- just modify the machine represented by $w$
so that, on input $y$,
it writes $x$ on the tape and runs the original algorithm.%
\footnote{
    Notice we are not manipulating the machine directly,
    only its representation as a string of bits.
}
This kind of modification can be done for any source code $w$
and any input $x$;
there is a computable function $\sigma$ of two variables
that is defined for every $w$ and $x$ such that,
for every $y$,
$\pi_w(x, y)$ is defined if and only if $\pi_{\sigma(w, x)}(y)$ is defined,
and, in this case,
\begin{equation*}
    \pi_w(x, y) = \pi_{\sigma(w, x)}(y).
\end{equation*}
This is the \emph{$S_{mn}$ theorem}.%
\footnote{
    The ``full version'' of this theorem asserts that,
    for any $m$ and $n$,
    there is a computable function $\sigma$ that,
    given a program $x$ for a function of $m + n$ variables
    and $n$ chosen values $y_1, \dots, y_m$,
    \begin{equation*}
        \pi_{\sigma(x, y_1, \dots, y_m)}(z_1, \dots, z_n) =
            \pi_x(y_1, \dots, y_m, z_1, \dots, z_n);
    \end{equation*}
    hence its name \cite[p.~23]{Rogers1987}.
}

These two theorems are all that Blum requires from a Gödel numbering
to define his axiomatic notion of complexity.
We have a special name (due to Rogers) for such numbering.

\begin{definition}
    An \emph{acceptable Gödel numbering}
    is a Gödel numbering $\phi$
    that satisfies both the universal machine theorem
    and the $S_{mn}$ theorem \cite[p.~41]{Rogers1987}.
    That is, there are computable functions $f$ and $\sigma$
    that satisfies
    \begin{itemize}
        \item For every $w$ and $x$,
            $f(w, x)$ is defined if and only if $\phi_w(x)$ is defined,
            and, in this case,
            \begin{equation*}
                f(w, x) = \phi_w(x);
            \end{equation*}
        \item $\sigma$ is defined for every $w$ and $x$,
            and, for every $y$,
            $\phi_w(x, y)$ is defined if and only if $\phi_{\sigma(w, x)}(y)$ is defined,
            and, in this case,
            \begin{equation*}
                \phi_w(x, y) = \phi_{\sigma(w, x)}(y).
            \end{equation*}
    \end{itemize}
\end{definition}

\subsection{Blum axioms}
\label{sec:blum-axioms}

With the mathematical notion of an acceptable Gödel numbering,
we can now define the Blum axioms for complexity measures.

\begin{definition}
    Given an acceptable Gödel numbering $\phi$,
    a \emph{complexity measure} for $\phi$
    is a function $\Phi:\Sigma^* \times \Sigma^* \to \mathbb N$ of two variables
    that satisfies: \cite[p.~324]{Blum1967}
    \begin{enumerate}
        \item For every $w$ and $x$,
            $\phi_w(x)$ exists if and only if $\Phi(w, x)$ exists.
        \item For every string $w$, $x$ and every natural number $k$,
            the predicate ``$\Phi(w, x) = k$?'' is decidable.
    \end{enumerate}
\end{definition}

$\Phi(w, x)$ is the complexity of computing $\phi_w(x)$
using the program $w$.
The first axiom says that it only makes sense
to talk about the complexity of a computation that ends.
The second axiom gives minimum tools to manipulate $\Phi$ indirectly,
in the same manner we require $\phi$ to be an \emph{acceptable} Gödel numbering.

\begin{example}
    Given the Gödel numbering $\pi$ of the previous chapter,
    the number of steps a Turing machine needs before halting
    is a complexity measure that satisfies Blum axioms.
    The corresponding function $\Phi$ is
    \begin{equation*}
        \Phi(w, x) = \begin{cases}
            k, &\text{if $w$ takes exactly $k$ steps on $x$ before halting} \\
            \text{undefined}, &\text{if $w$ never halts on $x$}
        \end{cases}
    \end{equation*}
    Then, $\Phi(w, x)$ is defined exactly when $\pi_w(x)$ exists
    (that is, when $w$ halts on $x$),
    and we can determine whether $\Phi(w, x) = k$ for a given $k$
    by simulating $w$ on $x$ for exactly $k$ steps.
\end{example}

\begin{example}
    Space complexity requires some care,
    because a machine may never halt even though it remains confined
    in a limited number of cells.
    Thus, we must leave the space complexity of a machine that never halts undefined.
    Formally, define the function $\Phi$ by
    \begin{equation*}
        \Phi(w, x) = \begin{cases}
            k, &\text{if $w$ uses exactly $k$ tape cells on $x$ before halting} \\
            \text{undefined}, &\text{if $w$ never halts on $x$}
        \end{cases}
    \end{equation*}
    This makes $\Phi$ satisfy the first axiom.
    To satisfy the second axiom,
    we must note that,
    if we limit the number of tape cells to $k$,
    there is a finite number of different computation states
    the machine can be.
    Therefore,
    to determine whether $\Phi(w, x) = k$,
    simulate $w$ on $x$ and keep the whole history of computation.
    If, in any point of the simulation,
    the machine $w$ uses more than $k$ tape cells,
    reject --- the answer is ``no''.
    If any two computation states repeat,
    then the machine will loop and never halt
    --- the answer is ``no'' again.
    Otherwise, the machine must halt
    (since there is a finite number of computation states).
    Now, when the machine halts,
    we just need to make sure it actually used exactly $k$ cells in one of its tapes.
\end{example}

\section{Nondeterministic computation of functions}

\subsection{Hopcroft-Ullman definition}
\subsection{Oded Goldreich definition}
\subsection{Krentel's $\OptP$ class}
\subsection{Valiant's $\#\P$ class}
\subsection{Alternative approaches for nondeterministic functions}

\bibliographystyle{sbc/sbc}
\bibliography{bib/bibliography}

\end{document}
