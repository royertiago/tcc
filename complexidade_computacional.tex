\chapter{COMPLEXIDADE COMPUTACIONAL}

A teoria da computabilidade
classifica os problemas computacionais entre
aqueles que podem e não podem ser resolvidos mecanicamente.
Existem diversos dispositivos matemáticos
que tentam capturar esta noção de
``resolvidos mecanicamente'';
o modelo que usaremos neste trabalho é a máquina de Turing.

Dizemos que um problema é \emph{decidível}
se ele puder ser resolvido por uma máquina de Turing.
Embora as máquinas de Turing
não se pareçam com os computadores modernos,
estes dois dispositivos são equivalentes,
no sentido de que
todos os problemas resolvíveis por um deles
também é resolvível pelo outro.
Portanto, podemos pensar nos problemas decidíveis
como aqueles que podem ser resolvidos com o uso de um computador
\cite[p. 307]{HopcroftMotwaniUllman2001}.
Embora a maior parte dos problemas
encontrados no dia-a-dia seja decidível,
existem alguns problemas de importância teórica e prática
que não o são.
% TODO: Adicionar citação aqui.
Um exemplo notável é determinar se dois programas são equivalentes.
\footnote{
    Este problema possui importância prática:
    caso existisse um algoritmo para determinar equivalência entre programas,
    poderíamos usar um computador para saber se
    determinado refatoramento ou otimização de código
    não alterou acidentalmente o significado do programa;
    isto é, a mudança não introduziu um bug.
}

Entretanto,
apenas ser decidível não é suficiente.
Existem alguns problemas
(de fato, categorias inteira deles)
que, por mais rápido que seja o computador
que esteja tentando resolvê-lo,
o tempo necessário torna-se excessivamente grande
muito rapidamente.
Chamamos estes problemas de \emph{intratáveis}
\cite[p. 1]{HopcroftMotwaniUllman2001}
Por mais que eles sejam decidíveis,
pode ser que demore até o Sol esfriar
(evento que estima-se que vá ocorrer em 5 bilhões de anos)
para que o computador devolva a solução.

É aqui que entra a teoria de complexidade computacional.
Essencialmente,
\emph{complexidade}
é a quantidade de recursos que são gastos
para obter a solução de determinado problema.
Geralmente nos concentramos em um único recurso;
pode ser o tempo de execução,
quantidade de memória RAM usada,
ou,
para a complexidade de circuitos,
a quantidade de portas lógicas
ou profundidade do circuito.

A literatura diverge um pouco nas definições.
O objetivo deste capítulo é consolidar
as notações e definições
que serão usadas no restante do trabalho.


\section{LINGUAGENS E MÁQUINAS}

\begin{definition}
    Um \emph{alfabeto}
    é um conjunto finito de símbolos,
    geralmente denotado por $\Sigma$.
    Seus elementos costumam ser denotados
    por letras no início do alfabeto latino:
    $a, b, c, \dots$.
\end{definition}
\begin{definition}
    Uma \emph{palavra} sobre um alfabeto
    é uma tupla ordenada de símbolos deste alfabeto.
    Tuplas costumam ser denotadas
    por letras no fim do alfabeto latino:
    $u, v, w, x, y, z$.
\end{definition}

Observe que o alfabeto
pode incluir qualquer caractere,
incluindo espaços em branco
e sinais de pontuação.
Portanto,
um texto inteiro
(como, por exemplo, este parágrafo),
é apenas uma palavra sobre um alfabeto específico.
Talvez um nome mais apropriado para este objeto matemático
seria \emph{sentença}.

\begin{definition}
    Dado um alfabeto $\Sigma$,
    $\Sigma^*$ é o conjunto de todas as palavras
    formadas com letras de $\Sigma$.
\end{definition}
Se $v = (a_1, a_2, \dots, a_n)$
e $w = (b_1, b_2, \dots, b_m)$,
a \emph{concatenação} de $v$ e $w$,
denotada $vw$,
é a tupla $(a_1, \dots, a_n, b_1, \dots, b_n)$.
A tupla vazia é chamada de $\varepsilon$.
Para qualquer palavra $w$,
temos $w\varepsilon = \epsilon w = w$;
portanto,
$\varepsilon$ é a identidade da operação de concatenação.
A operação de concatenação também é associativa.
Estas duas operações permite-nos concluir
que $\Sigma^*$ forma um monóide
com a operação de concatenação.

\begin{definition}
    Dado um alfabeto $\Sigma$,
    uma \emph{linguagem} sobre este alfabeto
    é um subconjunto de $\Sigma^*$.
\end{definition}
Esta talvez é a definição menos intuitiva desta seção.
Como uma linguagem,
que deveria ser uma ferramenta para transmitir mensagens
e sentimentos,
pode ser definida
meramente como um conjunto de palavras?

Como observado anteriormente,
palavras podem englobar sentenças inteiras.
Tais sentenças podem fazer sentido ou não;
a definição de linguagem
tenta capturar esta noção de ``fazer sentido''.
As sentenças que fazem sentido,
perante uma linguagem,
são justamente aquelas que \emph{pertencem} à linguagem.
Por exemplo, a linguagem do português
é o conjunto das sentenças
que obedecem às regras gramaticais
da lingua portuguesa;
uma linguagem de programação
é o conjunto dos códigos-fonte válidos para aquela linguagem
\cite[p. 31]{HopcroftMotwaniUllman2001}.

\subsection{Máquinas absortas (oblivious machines)}

\section{COMPLEXIDADE COMPUTACIONAL}

\subsection{P versus NP}
